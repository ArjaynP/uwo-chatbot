{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n    module.exports = require('next/dist/server/route-modules/app-page/module.js');\n} else {\n    if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n        if (process.env.NODE_ENV === 'development') {\n            if (process.env.TURBOPACK) {\n                module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js');\n            } else {\n                module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js');\n            }\n        } else {\n            if (process.env.TURBOPACK) {\n                module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js');\n            } else {\n                module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js');\n            }\n        }\n    } else {\n        if (process.env.NODE_ENV === 'development') {\n            if (process.env.TURBOPACK) {\n                module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js');\n            } else {\n                module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js');\n            }\n        } else {\n            if (process.env.TURBOPACK) {\n                module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js');\n            } else {\n                module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js');\n            }\n        }\n    }\n}\n\n//# sourceMappingURL=module.compiled.js.map"],"names":[],"mappings":"AAAA;;KAEO;IACH;;SAcO;QACH,wCAA4C;YACxC,wCAA2B;gBACvB,OAAO,OAAO;YAClB;;QAGJ;;IAOJ;AACJ,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 25, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/instrumentation/utils.js"],"sourcesContent":["export function getRevalidateReason(params) {\n    if (params.isOnDemandRevalidate) {\n        return 'on-demand';\n    }\n    if (params.isStaticGeneration) {\n        return 'stale';\n    }\n    return undefined;\n}\n\n//# sourceMappingURL=utils.js.map"],"names":[],"mappings":";;;;AAAO,SAAS,oBAAoB,MAAM;IACtC,IAAI,OAAO,oBAAoB,EAAE;QAC7B,OAAO;IACX;IACA,IAAI,OAAO,kBAAkB,EAAE;QAC3B,OAAO;IACX;IACA,OAAO;AACX,EAEA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 42, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/app-render/interop-default.js"],"sourcesContent":["/**\n * Interop between \"export default\" and \"module.exports\".\n */ export function interopDefault(mod) {\n    return mod.default || mod;\n}\n\n//# sourceMappingURL=interop-default.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;AAAU,SAAS,eAAe,GAAG;IAClC,OAAO,IAAI,OAAO,IAAI;AAC1B,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/app-render/strip-flight-headers.js"],"sourcesContent":["import { FLIGHT_HEADERS } from '../../client/components/app-router-headers';\n/**\n * Removes the flight headers from the request.\n *\n * @param req the request to strip the headers from\n */ export function stripFlightHeaders(headers) {\n    for (const header of FLIGHT_HEADERS){\n        delete headers[header];\n    }\n}\n\n//# sourceMappingURL=strip-flight-headers.js.map"],"names":[],"mappings":";;;;AAAA;;AAKW,SAAS,mBAAmB,OAAO;IAC1C,KAAK,MAAM,UAAU,2NAAc,CAAC;QAChC,OAAO,OAAO,CAAC,OAAO;IAC1B;AACJ,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/web/spec-extension/adapters/headers.js"],"sourcesContent":["import { ReflectAdapter } from './reflect';\n/**\n * @internal\n */ export class ReadonlyHeadersError extends Error {\n    constructor(){\n        super('Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers');\n    }\n    static callable() {\n        throw new ReadonlyHeadersError();\n    }\n}\nexport class HeadersAdapter extends Headers {\n    constructor(headers){\n        // We've already overridden the methods that would be called, so we're just\n        // calling the super constructor to ensure that the instanceof check works.\n        super();\n        this.headers = new Proxy(headers, {\n            get (target, prop, receiver) {\n                // Because this is just an object, we expect that all \"get\" operations\n                // are for properties. If it's a \"get\" for a symbol, we'll just return\n                // the symbol.\n                if (typeof prop === 'symbol') {\n                    return ReflectAdapter.get(target, prop, receiver);\n                }\n                const lowercased = prop.toLowerCase();\n                // Let's find the original casing of the key. This assumes that there is\n                // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n                // headers object.\n                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);\n                // If the original casing doesn't exist, return undefined.\n                if (typeof original === 'undefined') return;\n                // If the original casing exists, return the value.\n                return ReflectAdapter.get(target, original, receiver);\n            },\n            set (target, prop, value, receiver) {\n                if (typeof prop === 'symbol') {\n                    return ReflectAdapter.set(target, prop, value, receiver);\n                }\n                const lowercased = prop.toLowerCase();\n                // Let's find the original casing of the key. This assumes that there is\n                // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n                // headers object.\n                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);\n                // If the original casing doesn't exist, use the prop as the key.\n                return ReflectAdapter.set(target, original ?? prop, value, receiver);\n            },\n            has (target, prop) {\n                if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop);\n                const lowercased = prop.toLowerCase();\n                // Let's find the original casing of the key. This assumes that there is\n                // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n                // headers object.\n                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);\n                // If the original casing doesn't exist, return false.\n                if (typeof original === 'undefined') return false;\n                // If the original casing exists, return true.\n                return ReflectAdapter.has(target, original);\n            },\n            deleteProperty (target, prop) {\n                if (typeof prop === 'symbol') return ReflectAdapter.deleteProperty(target, prop);\n                const lowercased = prop.toLowerCase();\n                // Let's find the original casing of the key. This assumes that there is\n                // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n                // headers object.\n                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);\n                // If the original casing doesn't exist, return true.\n                if (typeof original === 'undefined') return true;\n                // If the original casing exists, delete the property.\n                return ReflectAdapter.deleteProperty(target, original);\n            }\n        });\n    }\n    /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */ static seal(headers) {\n        return new Proxy(headers, {\n            get (target, prop, receiver) {\n                switch(prop){\n                    case 'append':\n                    case 'delete':\n                    case 'set':\n                        return ReadonlyHeadersError.callable;\n                    default:\n                        return ReflectAdapter.get(target, prop, receiver);\n                }\n            }\n        });\n    }\n    /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */ merge(value) {\n        if (Array.isArray(value)) return value.join(', ');\n        return value;\n    }\n    /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */ static from(headers) {\n        if (headers instanceof Headers) return headers;\n        return new HeadersAdapter(headers);\n    }\n    append(name, value) {\n        const existing = this.headers[name];\n        if (typeof existing === 'string') {\n            this.headers[name] = [\n                existing,\n                value\n            ];\n        } else if (Array.isArray(existing)) {\n            existing.push(value);\n        } else {\n            this.headers[name] = value;\n        }\n    }\n    delete(name) {\n        delete this.headers[name];\n    }\n    get(name) {\n        const value = this.headers[name];\n        if (typeof value !== 'undefined') return this.merge(value);\n        return null;\n    }\n    has(name) {\n        return typeof this.headers[name] !== 'undefined';\n    }\n    set(name, value) {\n        this.headers[name] = value;\n    }\n    forEach(callbackfn, thisArg) {\n        for (const [name, value] of this.entries()){\n            callbackfn.call(thisArg, value, name, this);\n        }\n    }\n    *entries() {\n        for (const key of Object.keys(this.headers)){\n            const name = key.toLowerCase();\n            // We assert here that this is a string because we got it from the\n            // Object.keys() call above.\n            const value = this.get(name);\n            yield [\n                name,\n                value\n            ];\n        }\n    }\n    *keys() {\n        for (const key of Object.keys(this.headers)){\n            const name = key.toLowerCase();\n            yield name;\n        }\n    }\n    *values() {\n        for (const key of Object.keys(this.headers)){\n            // We assert here that this is a string because we got it from the\n            // Object.keys() call above.\n            const value = this.get(key);\n            yield value;\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n}\n\n//# sourceMappingURL=headers.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/compiled/cookie/index.js"],"sourcesContent":["(()=>{\"use strict\";if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var e={};(()=>{var r=e;\n/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */r.parse=parse;r.serialize=serialize;var i=decodeURIComponent;var t=encodeURIComponent;var a=/; */;var n=/^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;function parse(e,r){if(typeof e!==\"string\"){throw new TypeError(\"argument str must be a string\")}var t={};var n=r||{};var o=e.split(a);var s=n.decode||i;for(var p=0;p<o.length;p++){var f=o[p];var u=f.indexOf(\"=\");if(u<0){continue}var v=f.substr(0,u).trim();var c=f.substr(++u,f.length).trim();if('\"'==c[0]){c=c.slice(1,-1)}if(undefined==t[v]){t[v]=tryDecode(c,s)}}return t}function serialize(e,r,i){var a=i||{};var o=a.encode||t;if(typeof o!==\"function\"){throw new TypeError(\"option encode is invalid\")}if(!n.test(e)){throw new TypeError(\"argument name is invalid\")}var s=o(r);if(s&&!n.test(s)){throw new TypeError(\"argument val is invalid\")}var p=e+\"=\"+s;if(null!=a.maxAge){var f=a.maxAge-0;if(isNaN(f)||!isFinite(f)){throw new TypeError(\"option maxAge is invalid\")}p+=\"; Max-Age=\"+Math.floor(f)}if(a.domain){if(!n.test(a.domain)){throw new TypeError(\"option domain is invalid\")}p+=\"; Domain=\"+a.domain}if(a.path){if(!n.test(a.path)){throw new TypeError(\"option path is invalid\")}p+=\"; Path=\"+a.path}if(a.expires){if(typeof a.expires.toUTCString!==\"function\"){throw new TypeError(\"option expires is invalid\")}p+=\"; Expires=\"+a.expires.toUTCString()}if(a.httpOnly){p+=\"; HttpOnly\"}if(a.secure){p+=\"; Secure\"}if(a.sameSite){var u=typeof a.sameSite===\"string\"?a.sameSite.toLowerCase():a.sameSite;switch(u){case true:p+=\"; SameSite=Strict\";break;case\"lax\":p+=\"; SameSite=Lax\";break;case\"strict\":p+=\"; SameSite=Strict\";break;case\"none\":p+=\"; SameSite=None\";break;default:throw new TypeError(\"option sameSite is invalid\")}}return p}function tryDecode(e,r){try{return r(e)}catch(r){return e}}})();module.exports=e})();"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 370, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/api-utils/index.js"],"sourcesContent":["import { HeadersAdapter } from '../web/spec-extension/adapters/headers';\nimport { PRERENDER_REVALIDATE_HEADER, PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER } from '../../lib/constants';\nimport { getTracer } from '../lib/trace/tracer';\nimport { NodeSpan } from '../lib/trace/constants';\nexport function wrapApiHandler(page, handler) {\n    return (...args)=>{\n        getTracer().setRootSpanAttribute('next.route', page);\n        // Call API route method\n        return getTracer().trace(NodeSpan.runHandler, {\n            spanName: `executing api route (pages) ${page}`\n        }, ()=>handler(...args));\n    };\n}\n/**\n *\n * @param res response object\n * @param statusCode `HTTP` status code of response\n */ export function sendStatusCode(res, statusCode) {\n    res.statusCode = statusCode;\n    return res;\n}\n/**\n *\n * @param res response object\n * @param [statusOrUrl] `HTTP` status code of redirect\n * @param url URL of redirect\n */ export function redirect(res, statusOrUrl, url) {\n    if (typeof statusOrUrl === 'string') {\n        url = statusOrUrl;\n        statusOrUrl = 307;\n    }\n    if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {\n        throw Object.defineProperty(new Error(`Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`), \"__NEXT_ERROR_CODE\", {\n            value: \"E389\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    res.writeHead(statusOrUrl, {\n        Location: url\n    });\n    res.write(url);\n    res.end();\n    return res;\n}\nexport function checkIsOnDemandRevalidate(req, previewProps) {\n    const headers = HeadersAdapter.from(req.headers);\n    const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER);\n    const isOnDemandRevalidate = previewModeId === previewProps.previewModeId;\n    const revalidateOnlyGenerated = headers.has(PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER);\n    return {\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated\n    };\n}\nexport const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`;\nexport const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`;\nexport const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024;\nexport const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA);\nexport const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS);\nexport function clearPreviewData(res, options = {}) {\n    if (SYMBOL_CLEARED_COOKIES in res) {\n        return res;\n    }\n    const { serialize } = require('next/dist/compiled/cookie');\n    const previous = res.getHeader('Set-Cookie');\n    res.setHeader(`Set-Cookie`, [\n        ...typeof previous === 'string' ? [\n            previous\n        ] : Array.isArray(previous) ? previous : [],\n        serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {\n            // To delete a cookie, set `expires` to a date in the past:\n            // https://tools.ietf.org/html/rfc6265#section-4.1.1\n            // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n            expires: new Date(0),\n            httpOnly: true,\n            sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n            secure: process.env.NODE_ENV !== 'development',\n            path: '/',\n            ...options.path !== undefined ? {\n                path: options.path\n            } : undefined\n        }),\n        serialize(COOKIE_NAME_PRERENDER_DATA, '', {\n            // To delete a cookie, set `expires` to a date in the past:\n            // https://tools.ietf.org/html/rfc6265#section-4.1.1\n            // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n            expires: new Date(0),\n            httpOnly: true,\n            sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n            secure: process.env.NODE_ENV !== 'development',\n            path: '/',\n            ...options.path !== undefined ? {\n                path: options.path\n            } : undefined\n        })\n    ]);\n    Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {\n        value: true,\n        enumerable: false\n    });\n    return res;\n}\n/**\n * Custom error class\n */ export class ApiError extends Error {\n    constructor(statusCode, message){\n        super(message);\n        this.statusCode = statusCode;\n    }\n}\n/**\n * Sends error in `response`\n * @param res response object\n * @param statusCode of response\n * @param message of response\n */ export function sendError(res, statusCode, message) {\n    res.statusCode = statusCode;\n    res.statusMessage = message;\n    res.end(message);\n}\n/**\n * Execute getter function only if its needed\n * @param LazyProps `req` and `params` for lazyProp\n * @param prop name of property\n * @param getter function to get data\n */ export function setLazyProp({ req }, prop, getter) {\n    const opts = {\n        configurable: true,\n        enumerable: true\n    };\n    const optsReset = {\n        ...opts,\n        writable: true\n    };\n    Object.defineProperty(req, prop, {\n        ...opts,\n        get: ()=>{\n            const value = getter();\n            // we set the property on the object to avoid recalculating it\n            Object.defineProperty(req, prop, {\n                ...optsReset,\n                value\n            });\n            return value;\n        },\n        set: (value)=>{\n            Object.defineProperty(req, prop, {\n                ...optsReset,\n                value\n            });\n        }\n    });\n}\n\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;AACO,SAAS,eAAe,IAAI,EAAE,OAAO;IACxC,OAAO,CAAC,GAAG;QACP,IAAA,sMAAS,IAAG,oBAAoB,CAAC,cAAc;QAC/C,wBAAwB;QACxB,OAAO,IAAA,sMAAS,IAAG,KAAK,CAAC,wMAAQ,CAAC,UAAU,EAAE;YAC1C,UAAU,CAAC,4BAA4B,EAAE,MAAM;QACnD,GAAG,IAAI,WAAW;IACtB;AACJ;AAKW,SAAS,eAAe,GAAG,EAAE,UAAU;IAC9C,IAAI,UAAU,GAAG;IACjB,OAAO;AACX;AAMW,SAAS,SAAS,GAAG,EAAE,WAAW,EAAE,GAAG;IAC9C,IAAI,OAAO,gBAAgB,UAAU;QACjC,MAAM;QACN,cAAc;IAClB;IACA,IAAI,OAAO,gBAAgB,YAAY,OAAO,QAAQ,UAAU;QAC5D,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,qKAAqK,CAAC,GAAG,qBAAqB;YACjO,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;IACA,IAAI,SAAS,CAAC,aAAa;QACvB,UAAU;IACd;IACA,IAAI,KAAK,CAAC;IACV,IAAI,GAAG;IACP,OAAO;AACX;AACO,SAAS,0BAA0B,GAAG,EAAE,YAAY;IACvD,MAAM,UAAU,oOAAc,CAAC,IAAI,CAAC,IAAI,OAAO;IAC/C,MAAM,gBAAgB,QAAQ,GAAG,CAAC,wMAA2B;IAC7D,MAAM,uBAAuB,kBAAkB,aAAa,aAAa;IACzE,MAAM,0BAA0B,QAAQ,GAAG,CAAC,uNAA0C;IACtF,OAAO;QACH;QACA;IACJ;AACJ;AACO,MAAM,+BAA+B,CAAC,kBAAkB,CAAC;AACzD,MAAM,6BAA6B,CAAC,mBAAmB,CAAC;AACxD,MAAM,yBAAyB,IAAI,OAAO;AAC1C,MAAM,sBAAsB,OAAO;AACnC,MAAM,yBAAyB,OAAO;AACtC,SAAS,iBAAiB,GAAG,EAAE,UAAU,CAAC,CAAC;IAC9C,IAAI,0BAA0B,KAAK;QAC/B,OAAO;IACX;IACA,MAAM,EAAE,SAAS,EAAE;IACnB,MAAM,WAAW,IAAI,SAAS,CAAC;IAC/B,IAAI,SAAS,CAAC,CAAC,UAAU,CAAC,EAAE;WACrB,OAAO,aAAa,WAAW;YAC9B;SACH,GAAG,MAAM,OAAO,CAAC,YAAY,WAAW,EAAE;QAC3C,UAAU,8BAA8B,IAAI;YACxC,2DAA2D;YAC3D,oDAAoD;YACpD,wEAAwE;YACxE,SAAS,IAAI,KAAK;YAClB,UAAU;YACV,UAAU,sCAAyC,0BAAS;YAC5D,QAAQ,oDAAyB;YACjC,MAAM;YACN,GAAG,QAAQ,IAAI,KAAK,YAAY;gBAC5B,MAAM,QAAQ,IAAI;YACtB,IAAI,SAAS;QACjB;QACA,UAAU,4BAA4B,IAAI;YACtC,2DAA2D;YAC3D,oDAAoD;YACpD,wEAAwE;YACxE,SAAS,IAAI,KAAK;YAClB,UAAU;YACV,UAAU,sCAAyC,0BAAS;YAC5D,QAAQ,oDAAyB;YACjC,MAAM;YACN,GAAG,QAAQ,IAAI,KAAK,YAAY;gBAC5B,MAAM,QAAQ,IAAI;YACtB,IAAI,SAAS;QACjB;KACH;IACD,OAAO,cAAc,CAAC,KAAK,wBAAwB;QAC/C,OAAO;QACP,YAAY;IAChB;IACA,OAAO;AACX;AAGW,MAAM,iBAAiB;IAC9B,YAAY,UAAU,EAAE,OAAO,CAAC;QAC5B,KAAK,CAAC;QACN,IAAI,CAAC,UAAU,GAAG;IACtB;AACJ;AAMW,SAAS,UAAU,GAAG,EAAE,UAAU,EAAE,OAAO;IAClD,IAAI,UAAU,GAAG;IACjB,IAAI,aAAa,GAAG;IACpB,IAAI,GAAG,CAAC;AACZ;AAMW,SAAS,YAAY,EAAE,GAAG,EAAE,EAAE,IAAI,EAAE,MAAM;IACjD,MAAM,OAAO;QACT,cAAc;QACd,YAAY;IAChB;IACA,MAAM,YAAY;QACd,GAAG,IAAI;QACP,UAAU;IACd;IACA,OAAO,cAAc,CAAC,KAAK,MAAM;QAC7B,GAAG,IAAI;QACP,KAAK;YACD,MAAM,QAAQ;YACd,8DAA8D;YAC9D,OAAO,cAAc,CAAC,KAAK,MAAM;gBAC7B,GAAG,SAAS;gBACZ;YACJ;YACA,OAAO;QACX;QACA,KAAK,CAAC;YACF,OAAO,cAAc,CAAC,KAAK,MAAM;gBAC7B,GAAG,SAAS;gBACZ;YACJ;QACJ;IACJ;AACJ,EAEA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 539, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/api-utils/get-cookie-parser.js"],"sourcesContent":["/**\n * Parse cookies from the `headers` of request\n * @param req request object\n */ export function getCookieParser(headers) {\n    return function parseCookie() {\n        const { cookie } = headers;\n        if (!cookie) {\n            return {};\n        }\n        const { parse: parseCookieFn } = require('next/dist/compiled/cookie');\n        return parseCookieFn(Array.isArray(cookie) ? cookie.join('; ') : cookie);\n    };\n}\n\n//# sourceMappingURL=get-cookie-parser.js.map"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAAU,SAAS,gBAAgB,OAAO;IACvC,OAAO,SAAS;QACZ,MAAM,EAAE,MAAM,EAAE,GAAG;QACnB,IAAI,CAAC,QAAQ;YACT,OAAO,CAAC;QACZ;QACA,MAAM,EAAE,OAAO,aAAa,EAAE;QAC9B,OAAO,cAAc,MAAM,OAAO,CAAC,UAAU,OAAO,IAAI,CAAC,QAAQ;IACrE;AACJ,EAEA,6CAA6C","ignoreList":[0]}},
    {"offset": {"line": 560, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/base-http/index.js"],"sourcesContent":["import { RedirectStatusCode } from '../../client/components/redirect-status-code';\nimport { getCookieParser } from '../api-utils/get-cookie-parser';\nexport class BaseNextRequest {\n    constructor(method, url, body){\n        this.method = method;\n        this.url = url;\n        this.body = body;\n    }\n    // Utils implemented using the abstract methods above\n    get cookies() {\n        if (this._cookies) return this._cookies;\n        return this._cookies = getCookieParser(this.headers)();\n    }\n}\nexport class BaseNextResponse {\n    constructor(destination){\n        this.destination = destination;\n    }\n    // Utils implemented using the abstract methods above\n    redirect(destination, statusCode) {\n        this.setHeader('Location', destination);\n        this.statusCode = statusCode;\n        // Since IE11 doesn't support the 308 header add backwards\n        // compatibility using refresh header\n        if (statusCode === RedirectStatusCode.PermanentRedirect) {\n            this.setHeader('Refresh', `0;url=${destination}`);\n        }\n        return this;\n    }\n}\n\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AACO,MAAM;IACT,YAAY,MAAM,EAAE,GAAG,EAAE,IAAI,CAAC;QAC1B,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,IAAI,GAAG;IAChB;IACA,qDAAqD;IACrD,IAAI,UAAU;QACV,IAAI,IAAI,CAAC,QAAQ,EAAE,OAAO,IAAI,CAAC,QAAQ;QACvC,OAAO,IAAI,CAAC,QAAQ,GAAG,IAAA,6NAAe,EAAC,IAAI,CAAC,OAAO;IACvD;AACJ;AACO,MAAM;IACT,YAAY,WAAW,CAAC;QACpB,IAAI,CAAC,WAAW,GAAG;IACvB;IACA,qDAAqD;IACrD,SAAS,WAAW,EAAE,UAAU,EAAE;QAC9B,IAAI,CAAC,SAAS,CAAC,YAAY;QAC3B,IAAI,CAAC,UAAU,GAAG;QAClB,0DAA0D;QAC1D,qCAAqC;QACrC,IAAI,eAAe,iOAAkB,CAAC,iBAAiB,EAAE;YACrD,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,MAAM,EAAE,aAAa;QACpD;QACA,OAAO,IAAI;IACf;AACJ,EAEA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 602, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/base-http/node.js"],"sourcesContent":["import { SYMBOL_CLEARED_COOKIES } from '../api-utils';\nimport { NEXT_REQUEST_META } from '../request-meta';\nimport { BaseNextRequest, BaseNextResponse } from './index';\nlet prop;\nexport class NodeNextRequest extends BaseNextRequest {\n    static #_ = prop = _NEXT_REQUEST_META = NEXT_REQUEST_META;\n    constructor(_req){\n        var _this__req;\n        super(_req.method.toUpperCase(), _req.url, _req), this._req = _req, this.headers = this._req.headers, this.fetchMetrics = (_this__req = this._req) == null ? void 0 : _this__req.fetchMetrics, this[_NEXT_REQUEST_META] = this._req[NEXT_REQUEST_META] || {}, this.streaming = false;\n    }\n    get originalRequest() {\n        // Need to mimic these changes to the original req object for places where we use it:\n        // render.tsx, api/ssg requests\n        this._req[NEXT_REQUEST_META] = this[NEXT_REQUEST_META];\n        this._req.url = this.url;\n        this._req.cookies = this.cookies;\n        return this._req;\n    }\n    set originalRequest(value) {\n        this._req = value;\n    }\n    /**\n   * Returns the request body as a Web Readable Stream. The body here can only\n   * be read once as the body will start flowing as soon as the data handler\n   * is attached.\n   *\n   * @internal\n   */ stream() {\n        if (this.streaming) {\n            throw Object.defineProperty(new Error('Invariant: NodeNextRequest.stream() can only be called once'), \"__NEXT_ERROR_CODE\", {\n                value: \"E467\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        this.streaming = true;\n        return new ReadableStream({\n            start: (controller)=>{\n                this._req.on('data', (chunk)=>{\n                    controller.enqueue(new Uint8Array(chunk));\n                });\n                this._req.on('end', ()=>{\n                    controller.close();\n                });\n                this._req.on('error', (err)=>{\n                    controller.error(err);\n                });\n            }\n        });\n    }\n}\nexport class NodeNextResponse extends BaseNextResponse {\n    get originalResponse() {\n        if (SYMBOL_CLEARED_COOKIES in this) {\n            this._res[SYMBOL_CLEARED_COOKIES] = this[SYMBOL_CLEARED_COOKIES];\n        }\n        return this._res;\n    }\n    constructor(_res){\n        super(_res), this._res = _res, this.textBody = undefined;\n    }\n    get sent() {\n        return this._res.finished || this._res.headersSent;\n    }\n    get statusCode() {\n        return this._res.statusCode;\n    }\n    set statusCode(value) {\n        this._res.statusCode = value;\n    }\n    get statusMessage() {\n        return this._res.statusMessage;\n    }\n    set statusMessage(value) {\n        this._res.statusMessage = value;\n    }\n    setHeader(name, value) {\n        this._res.setHeader(name, value);\n        return this;\n    }\n    removeHeader(name) {\n        this._res.removeHeader(name);\n        return this;\n    }\n    getHeaderValues(name) {\n        const values = this._res.getHeader(name);\n        if (values === undefined) return undefined;\n        return (Array.isArray(values) ? values : [\n            values\n        ]).map((value)=>value.toString());\n    }\n    hasHeader(name) {\n        return this._res.hasHeader(name);\n    }\n    getHeader(name) {\n        const values = this.getHeaderValues(name);\n        return Array.isArray(values) ? values.join(',') : undefined;\n    }\n    getHeaders() {\n        return this._res.getHeaders();\n    }\n    appendHeader(name, value) {\n        const currentValues = this.getHeaderValues(name) ?? [];\n        if (!currentValues.includes(value)) {\n            this._res.setHeader(name, [\n                ...currentValues,\n                value\n            ]);\n        }\n        return this;\n    }\n    body(value) {\n        this.textBody = value;\n        return this;\n    }\n    send() {\n        this._res.end(this.textBody);\n    }\n    onClose(callback) {\n        this.originalResponse.on('close', callback);\n    }\n}\nvar _NEXT_REQUEST_META;\n\n//# sourceMappingURL=node.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 738, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/lib/experimental/ppr.js"],"sourcesContent":["/**\n * If set to `incremental`, only those leaf pages that export\n * `experimental_ppr = true` will have partial prerendering enabled. If any\n * page exports this value as `false` or does not export it at all will not\n * have partial prerendering enabled. If set to a boolean, the options for\n * `experimental_ppr` will be ignored.\n */ /**\n * Returns true if partial prerendering is enabled for the application. It does\n * not tell you if a given route has PPR enabled, as that requires analysis of\n * the route's configuration.\n *\n * @see {@link checkIsRoutePPREnabled} - for checking if a specific route has PPR enabled.\n */ export function checkIsAppPPREnabled(config) {\n    // If the config is undefined, partial prerendering is disabled.\n    if (typeof config === 'undefined') return false;\n    // If the config is a boolean, use it directly.\n    if (typeof config === 'boolean') return config;\n    // If the config is a string, it must be 'incremental' to enable partial\n    // prerendering.\n    if (config === 'incremental') return true;\n    return false;\n}\n/**\n * Returns true if partial prerendering is supported for the current page with\n * the provided app configuration. If the application doesn't have partial\n * prerendering enabled, this function will always return false. If you want to\n * check if the application has partial prerendering enabled\n *\n * @see {@link checkIsAppPPREnabled} for checking if the application has PPR enabled.\n */ export function checkIsRoutePPREnabled(config) {\n    // If the config is undefined, partial prerendering is disabled.\n    if (typeof config === 'undefined') return false;\n    // If the config is a boolean, use it directly.\n    if (typeof config === 'boolean') return config;\n    return false;\n}\n\n//# sourceMappingURL=ppr.js.map"],"names":[],"mappings":"AAAA;;;;;;CAMC,GAAG;;;;;;CAMH;;;;;;AAAU,SAAS,qBAAqB,MAAM;IAC3C,gEAAgE;IAChE,IAAI,OAAO,WAAW,aAAa,OAAO;IAC1C,+CAA+C;IAC/C,IAAI,OAAO,WAAW,WAAW,OAAO;IACxC,wEAAwE;IACxE,gBAAgB;IAChB,IAAI,WAAW,eAAe,OAAO;IACrC,OAAO;AACX;AAQW,SAAS,uBAAuB,MAAM;IAC7C,gEAAgE;IAChE,IAAI,OAAO,WAAW,aAAa,OAAO;IAC1C,+CAA+C;IAC/C,IAAI,OAAO,WAAW,WAAW,OAAO;IACxC,OAAO;AACX,EAEA,+BAA+B","ignoreList":[0]}},
    {"offset": {"line": 777, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/route-modules/checks.js"],"sourcesContent":["import { RouteKind } from '../route-kind';\nexport function isAppRouteRouteModule(routeModule) {\n    return routeModule.definition.kind === RouteKind.APP_ROUTE;\n}\nexport function isAppPageRouteModule(routeModule) {\n    return routeModule.definition.kind === RouteKind.APP_PAGE;\n}\nexport function isPagesRouteModule(routeModule) {\n    return routeModule.definition.kind === RouteKind.PAGES;\n}\nexport function isPagesAPIRouteModule(routeModule) {\n    return routeModule.definition.kind === RouteKind.PAGES_API;\n}\n\n//# sourceMappingURL=checks.js.map"],"names":[],"mappings":";;;;;;;;;;AAAA;;AACO,SAAS,sBAAsB,WAAW;IAC7C,OAAO,YAAY,UAAU,CAAC,IAAI,KAAK,6LAAS,CAAC,SAAS;AAC9D;AACO,SAAS,qBAAqB,WAAW;IAC5C,OAAO,YAAY,UAAU,CAAC,IAAI,KAAK,6LAAS,CAAC,QAAQ;AAC7D;AACO,SAAS,mBAAmB,WAAW;IAC1C,OAAO,YAAY,UAAU,CAAC,IAAI,KAAK,6LAAS,CAAC,KAAK;AAC1D;AACO,SAAS,sBAAsB,WAAW;IAC7C,OAAO,YAAY,UAAU,CAAC,IAAI,KAAK,6LAAS,CAAC,SAAS;AAC9D,EAEA,kCAAkC","ignoreList":[0]}},
    {"offset": {"line": 805, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/shared/lib/page-path/ensure-leading-slash.js"],"sourcesContent":["/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */ export function ensureLeadingSlash(path) {\n    return path.startsWith('/') ? path : `/${path}`;\n}\n\n//# sourceMappingURL=ensure-leading-slash.js.map"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAAU,SAAS,mBAAmB,IAAI;IACvC,OAAO,KAAK,UAAU,CAAC,OAAO,OAAO,CAAC,CAAC,EAAE,MAAM;AACnD,EAEA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 819, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/shared/lib/router/utils/app-paths.js"],"sourcesContent":["import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash';\nimport { isGroupSegment } from '../../segment';\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */ export function normalizeAppPath(route) {\n    return ensureLeadingSlash(route.split('/').reduce((pathname, segment, index, segments)=>{\n        // Empty segments are ignored.\n        if (!segment) {\n            return pathname;\n        }\n        // Groups are ignored.\n        if (isGroupSegment(segment)) {\n            return pathname;\n        }\n        // Parallel segments are ignored.\n        if (segment[0] === '@') {\n            return pathname;\n        }\n        // The last segment (if it's a leaf) should be ignored.\n        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {\n            return pathname;\n        }\n        return `${pathname}/${segment}`;\n    }, ''));\n}\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */ export function normalizeRscURL(url) {\n    return url.replace(/\\.rsc($|\\?)/, // $1 ensures `?` is preserved\n    '$1');\n}\n\n//# sourceMappingURL=app-paths.js.map"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAmBW,SAAS,iBAAiB,KAAK;IACtC,OAAO,IAAA,0OAAkB,EAAC,MAAM,KAAK,CAAC,KAAK,MAAM,CAAC,CAAC,UAAU,SAAS,OAAO;QACzE,8BAA8B;QAC9B,IAAI,CAAC,SAAS;YACV,OAAO;QACX;QACA,sBAAsB;QACtB,IAAI,IAAA,mMAAc,EAAC,UAAU;YACzB,OAAO;QACX;QACA,iCAAiC;QACjC,IAAI,OAAO,CAAC,EAAE,KAAK,KAAK;YACpB,OAAO;QACX;QACA,uDAAuD;QACvD,IAAI,CAAC,YAAY,UAAU,YAAY,OAAO,KAAK,UAAU,SAAS,MAAM,GAAG,GAAG;YAC9E,OAAO;QACX;QACA,OAAO,GAAG,SAAS,CAAC,EAAE,SAAS;IACnC,GAAG;AACP;AAIW,SAAS,gBAAgB,GAAG;IACnC,OAAO,IAAI,OAAO,CAAC,eACnB;AACJ,EAEA,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 857, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/shared/lib/router/utils/interception-routes.js"],"sourcesContent":["import { normalizeAppPath } from './app-paths';\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n    '(..)(..)',\n    '(.)',\n    '(..)',\n    '(...)'\n];\nexport function isInterceptionRouteAppPath(path) {\n    // TODO-APP: add more serious validation\n    return path.split('/').find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;\n}\nexport function extractInterceptionRouteInformation(path) {\n    let interceptingRoute;\n    let marker;\n    let interceptedRoute;\n    for (const segment of path.split('/')){\n        marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n        if (marker) {\n            ;\n            [interceptingRoute, interceptedRoute] = path.split(marker, 2);\n            break;\n        }\n    }\n    if (!interceptingRoute || !marker || !interceptedRoute) {\n        throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`), \"__NEXT_ERROR_CODE\", {\n            value: \"E269\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n    ;\n    switch(marker){\n        case '(.)':\n            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n            if (interceptingRoute === '/') {\n                interceptedRoute = `/${interceptedRoute}`;\n            } else {\n                interceptedRoute = interceptingRoute + '/' + interceptedRoute;\n            }\n            break;\n        case '(..)':\n            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n            if (interceptingRoute === '/') {\n                throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E207\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');\n            break;\n        case '(...)':\n            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n            interceptedRoute = '/' + interceptedRoute;\n            break;\n        case '(..)(..)':\n            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n            const splitInterceptingRoute = interceptingRoute.split('/');\n            if (splitInterceptingRoute.length <= 2) {\n                throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E486\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');\n            break;\n        default:\n            throw Object.defineProperty(new Error('Invariant: unexpected marker'), \"__NEXT_ERROR_CODE\", {\n                value: \"E112\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n    return {\n        interceptingRoute,\n        interceptedRoute\n    };\n}\n\n//# sourceMappingURL=interception-routes.js.map"],"names":[],"mappings":";;;;;;;;AAAA;;AAEO,MAAM,6BAA6B;IACtC;IACA;IACA;IACA;CACH;AACM,SAAS,2BAA2B,IAAI;IAC3C,wCAAwC;IACxC,OAAO,KAAK,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC,UAAU,2BAA2B,IAAI,CAAC,CAAC,IAAI,QAAQ,UAAU,CAAC,SAAS;AAC5G;AACO,SAAS,oCAAoC,IAAI;IACpD,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,KAAK,MAAM,WAAW,KAAK,KAAK,CAAC,KAAK;QAClC,SAAS,2BAA2B,IAAI,CAAC,CAAC,IAAI,QAAQ,UAAU,CAAC;QACjE,IAAI,QAAQ;;YAER,CAAC,mBAAmB,iBAAiB,GAAG,KAAK,KAAK,CAAC,QAAQ;YAC3D;QACJ;IACJ;IACA,IAAI,CAAC,qBAAqB,CAAC,UAAU,CAAC,kBAAkB;QACpD,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,iFAAiF,CAAC,GAAG,qBAAqB;YAChL,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;IACA,oBAAoB,IAAA,6NAAgB,EAAC,mBAAmB,iDAAiD;;IAEzG,OAAO;QACH,KAAK;YACD,oIAAoI;YACpI,IAAI,sBAAsB,KAAK;gBAC3B,mBAAmB,CAAC,CAAC,EAAE,kBAAkB;YAC7C,OAAO;gBACH,mBAAmB,oBAAoB,MAAM;YACjD;YACA;QACJ,KAAK;YACD,uHAAuH;YACvH,IAAI,sBAAsB,KAAK;gBAC3B,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,4DAA4D,CAAC,GAAG,qBAAqB;oBAC3J,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;YACJ;YACA,mBAAmB,kBAAkB,KAAK,CAAC,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,kBAAkB,IAAI,CAAC;YAC3F;QACJ,KAAK;YACD,kIAAkI;YAClI,mBAAmB,MAAM;YACzB;QACJ,KAAK;YACD,iIAAiI;YACjI,MAAM,yBAAyB,kBAAkB,KAAK,CAAC;YACvD,IAAI,uBAAuB,MAAM,IAAI,GAAG;gBACpC,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,+DAA+D,CAAC,GAAG,qBAAqB;oBAC9J,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;YACJ;YACA,mBAAmB,uBAAuB,KAAK,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,kBAAkB,IAAI,CAAC;YACrF;QACJ;YACI,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,iCAAiC,qBAAqB;gBACxF,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;IACR;IACA,OAAO;QACH;QACA;IACJ;AACJ,EAEA,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 950, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/shared/lib/router/utils/get-segment-param.js"],"sourcesContent":["import { INTERCEPTION_ROUTE_MARKERS } from './interception-routes';\n/**\n * Parse dynamic route segment to type of parameter\n */ export function getSegmentParam(segment) {\n    const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((marker)=>segment.startsWith(marker));\n    // if an interception marker is part of the path segment, we need to jump ahead\n    // to the relevant portion for param parsing\n    if (interceptionMarker) {\n        segment = segment.slice(interceptionMarker.length);\n    }\n    if (segment.startsWith('[[...') && segment.endsWith(']]')) {\n        return {\n            // TODO-APP: Optional catchall does not currently work with parallel routes,\n            // so for now aren't handling a potential interception marker.\n            paramType: 'optional-catchall',\n            paramName: segment.slice(5, -2)\n        };\n    }\n    if (segment.startsWith('[...') && segment.endsWith(']')) {\n        return {\n            paramType: interceptionMarker ? `catchall-intercepted-${interceptionMarker}` : 'catchall',\n            paramName: segment.slice(4, -1)\n        };\n    }\n    if (segment.startsWith('[') && segment.endsWith(']')) {\n        return {\n            paramType: interceptionMarker ? `dynamic-intercepted-${interceptionMarker}` : 'dynamic',\n            paramName: segment.slice(1, -1)\n        };\n    }\n    return null;\n}\nexport function isCatchAll(type) {\n    return type === 'catchall' || type === 'catchall-intercepted-(..)(..)' || type === 'catchall-intercepted-(.)' || type === 'catchall-intercepted-(..)' || type === 'catchall-intercepted-(...)' || type === 'optional-catchall';\n}\nexport function getParamProperties(paramType) {\n    let repeat = false;\n    let optional = false;\n    switch(paramType){\n        case 'catchall':\n        case 'catchall-intercepted-(..)(..)':\n        case 'catchall-intercepted-(.)':\n        case 'catchall-intercepted-(..)':\n        case 'catchall-intercepted-(...)':\n            repeat = true;\n            break;\n        case 'optional-catchall':\n            repeat = true;\n            optional = true;\n            break;\n        case 'dynamic':\n        case 'dynamic-intercepted-(..)(..)':\n        case 'dynamic-intercepted-(.)':\n        case 'dynamic-intercepted-(..)':\n        case 'dynamic-intercepted-(...)':\n            break;\n        default:\n            paramType;\n    }\n    return {\n        repeat,\n        optional\n    };\n}\n\n//# sourceMappingURL=get-segment-param.js.map"],"names":[],"mappings":";;;;;;;;AAAA;;AAGW,SAAS,gBAAgB,OAAO;IACvC,MAAM,qBAAqB,iPAA0B,CAAC,IAAI,CAAC,CAAC,SAAS,QAAQ,UAAU,CAAC;IACxF,+EAA+E;IAC/E,4CAA4C;IAC5C,IAAI,oBAAoB;QACpB,UAAU,QAAQ,KAAK,CAAC,mBAAmB,MAAM;IACrD;IACA,IAAI,QAAQ,UAAU,CAAC,YAAY,QAAQ,QAAQ,CAAC,OAAO;QACvD,OAAO;YACH,4EAA4E;YAC5E,8DAA8D;YAC9D,WAAW;YACX,WAAW,QAAQ,KAAK,CAAC,GAAG,CAAC;QACjC;IACJ;IACA,IAAI,QAAQ,UAAU,CAAC,WAAW,QAAQ,QAAQ,CAAC,MAAM;QACrD,OAAO;YACH,WAAW,qBAAqB,CAAC,qBAAqB,EAAE,oBAAoB,GAAG;YAC/E,WAAW,QAAQ,KAAK,CAAC,GAAG,CAAC;QACjC;IACJ;IACA,IAAI,QAAQ,UAAU,CAAC,QAAQ,QAAQ,QAAQ,CAAC,MAAM;QAClD,OAAO;YACH,WAAW,qBAAqB,CAAC,oBAAoB,EAAE,oBAAoB,GAAG;YAC9E,WAAW,QAAQ,KAAK,CAAC,GAAG,CAAC;QACjC;IACJ;IACA,OAAO;AACX;AACO,SAAS,WAAW,IAAI;IAC3B,OAAO,SAAS,cAAc,SAAS,mCAAmC,SAAS,8BAA8B,SAAS,+BAA+B,SAAS,gCAAgC,SAAS;AAC/M;AACO,SAAS,mBAAmB,SAAS;IACxC,IAAI,SAAS;IACb,IAAI,WAAW;IACf,OAAO;QACH,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACD,SAAS;YACT;QACJ,KAAK;YACD,SAAS;YACT,WAAW;YACX;QACJ,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACD;QACJ;YACI;IACR;IACA,OAAO;QACH;QACA;IACJ;AACJ,EAEA,6CAA6C","ignoreList":[0]}},
    {"offset": {"line": 1025, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/shared/lib/router/routes/app.js"],"sourcesContent":["import { InvariantError } from '../../invariant-error';\nimport { getSegmentParam } from '../utils/get-segment-param';\nimport { INTERCEPTION_ROUTE_MARKERS } from '../utils/interception-routes';\nexport function parseAppRouteSegment(segment) {\n    if (segment === '') {\n        return null;\n    }\n    // Check if the segment starts with an interception marker\n    const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n    const param = getSegmentParam(segment);\n    if (param) {\n        return {\n            type: 'dynamic',\n            name: segment,\n            param,\n            interceptionMarker\n        };\n    } else if (segment.startsWith('(') && segment.endsWith(')')) {\n        return {\n            type: 'route-group',\n            name: segment,\n            interceptionMarker\n        };\n    } else if (segment.startsWith('@')) {\n        return {\n            type: 'parallel-route',\n            name: segment,\n            interceptionMarker\n        };\n    } else {\n        return {\n            type: 'static',\n            name: segment,\n            interceptionMarker\n        };\n    }\n}\nexport function isNormalizedAppRoute(route) {\n    return route.normalized;\n}\nexport function isInterceptionAppRoute(route) {\n    return route.interceptionMarker !== undefined && route.interceptingRoute !== undefined && route.interceptedRoute !== undefined;\n}\nexport function parseAppRoute(pathname, normalized) {\n    const pathnameSegments = pathname.split('/').filter(Boolean);\n    // Build segments array with static and dynamic segments\n    const segments = [];\n    // Parse if this is an interception route.\n    let interceptionMarker;\n    let interceptingRoute;\n    let interceptedRoute;\n    for (const segment of pathnameSegments){\n        // Parse the segment into an AppSegment.\n        const appSegment = parseAppRouteSegment(segment);\n        if (!appSegment) {\n            continue;\n        }\n        if (normalized && (appSegment.type === 'route-group' || appSegment.type === 'parallel-route')) {\n            throw Object.defineProperty(new InvariantError(`${pathname} is being parsed as a normalized route, but it has a route group or parallel route segment.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E923\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        segments.push(appSegment);\n        if (appSegment.interceptionMarker) {\n            const parts = pathname.split(appSegment.interceptionMarker);\n            if (parts.length !== 2) {\n                throw Object.defineProperty(new Error(`Invalid interception route: ${pathname}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E924\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            interceptingRoute = normalized ? parseAppRoute(parts[0], true) : parseAppRoute(parts[0], false);\n            interceptedRoute = normalized ? parseAppRoute(parts[1], true) : parseAppRoute(parts[1], false);\n            interceptionMarker = appSegment.interceptionMarker;\n        }\n    }\n    const dynamicSegments = segments.filter((segment)=>segment.type === 'dynamic');\n    return {\n        normalized,\n        pathname,\n        segments,\n        dynamicSegments,\n        interceptionMarker,\n        interceptingRoute,\n        interceptedRoute\n    };\n}\n\n//# sourceMappingURL=app.js.map"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;;;;AACO,SAAS,qBAAqB,OAAO;IACxC,IAAI,YAAY,IAAI;QAChB,OAAO;IACX;IACA,0DAA0D;IAC1D,MAAM,qBAAqB,iPAA0B,CAAC,IAAI,CAAC,CAAC,IAAI,QAAQ,UAAU,CAAC;IACnF,MAAM,QAAQ,IAAA,uOAAe,EAAC;IAC9B,IAAI,OAAO;QACP,OAAO;YACH,MAAM;YACN,MAAM;YACN;YACA;QACJ;IACJ,OAAO,IAAI,QAAQ,UAAU,CAAC,QAAQ,QAAQ,QAAQ,CAAC,MAAM;QACzD,OAAO;YACH,MAAM;YACN,MAAM;YACN;QACJ;IACJ,OAAO,IAAI,QAAQ,UAAU,CAAC,MAAM;QAChC,OAAO;YACH,MAAM;YACN,MAAM;YACN;QACJ;IACJ,OAAO;QACH,OAAO;YACH,MAAM;YACN,MAAM;YACN;QACJ;IACJ;AACJ;AACO,SAAS,qBAAqB,KAAK;IACtC,OAAO,MAAM,UAAU;AAC3B;AACO,SAAS,uBAAuB,KAAK;IACxC,OAAO,MAAM,kBAAkB,KAAK,aAAa,MAAM,iBAAiB,KAAK,aAAa,MAAM,gBAAgB,KAAK;AACzH;AACO,SAAS,cAAc,QAAQ,EAAE,UAAU;IAC9C,MAAM,mBAAmB,SAAS,KAAK,CAAC,KAAK,MAAM,CAAC;IACpD,wDAAwD;IACxD,MAAM,WAAW,EAAE;IACnB,0CAA0C;IAC1C,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,KAAK,MAAM,WAAW,iBAAiB;QACnC,wCAAwC;QACxC,MAAM,aAAa,qBAAqB;QACxC,IAAI,CAAC,YAAY;YACb;QACJ;QACA,IAAI,cAAc,CAAC,WAAW,IAAI,KAAK,iBAAiB,WAAW,IAAI,KAAK,gBAAgB,GAAG;YAC3F,MAAM,OAAO,cAAc,CAAC,IAAI,8MAAc,CAAC,GAAG,SAAS,2FAA2F,CAAC,GAAG,qBAAqB;gBAC3K,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;QACJ;QACA,SAAS,IAAI,CAAC;QACd,IAAI,WAAW,kBAAkB,EAAE;YAC/B,MAAM,QAAQ,SAAS,KAAK,CAAC,WAAW,kBAAkB;YAC1D,IAAI,MAAM,MAAM,KAAK,GAAG;gBACpB,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,4BAA4B,EAAE,UAAU,GAAG,qBAAqB;oBACnG,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;YACJ;YACA,oBAAoB,aAAa,cAAc,KAAK,CAAC,EAAE,EAAE,QAAQ,cAAc,KAAK,CAAC,EAAE,EAAE;YACzF,mBAAmB,aAAa,cAAc,KAAK,CAAC,EAAE,EAAE,QAAQ,cAAc,KAAK,CAAC,EAAE,EAAE;YACxF,qBAAqB,WAAW,kBAAkB;QACtD;IACJ;IACA,MAAM,kBAAkB,SAAS,MAAM,CAAC,CAAC,UAAU,QAAQ,IAAI,KAAK;IACpE,OAAO;QACH;QACA;QACA;QACA;QACA;QACA;QACA;IACJ;AACJ,EAEA,+BAA+B","ignoreList":[0]}},
    {"offset": {"line": 1132, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/shared/lib/router/utils/parse-loader-tree.js"],"sourcesContent":["import { DEFAULT_SEGMENT_KEY } from '../../segment';\nexport function parseLoaderTree(tree) {\n    const [segment, parallelRoutes, modules] = tree;\n    const { layout, template } = modules;\n    let { page } = modules;\n    // a __DEFAULT__ segment means that this route didn't match any of the\n    // segments in the route, so we should use the default page\n    page = segment === DEFAULT_SEGMENT_KEY ? modules.defaultPage : page;\n    const conventionPath = layout?.[1] || template?.[1] || page?.[1];\n    return {\n        page,\n        segment,\n        modules,\n        /* it can be either layout / template / page */ conventionPath,\n        parallelRoutes\n    };\n}\n\n//# sourceMappingURL=parse-loader-tree.js.map"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,gBAAgB,IAAI;IAChC,MAAM,CAAC,SAAS,gBAAgB,QAAQ,GAAG;IAC3C,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG;IAC7B,IAAI,EAAE,IAAI,EAAE,GAAG;IACf,sEAAsE;IACtE,2DAA2D;IAC3D,OAAO,YAAY,wMAAmB,GAAG,QAAQ,WAAW,GAAG;IAC/D,MAAM,iBAAiB,QAAQ,CAAC,EAAE,IAAI,UAAU,CAAC,EAAE,IAAI,MAAM,CAAC,EAAE;IAChE,OAAO;QACH;QACA;QACA;QACA,6CAA6C,GAAG;QAChD;IACJ;AACJ,EAEA,6CAA6C","ignoreList":[0]}},
    {"offset": {"line": 1158, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/shared/lib/router/utils/interception-prefix-from-param-type.js"],"sourcesContent":["export function interceptionPrefixFromParamType(paramType) {\n    switch(paramType){\n        case 'catchall-intercepted-(..)(..)':\n        case 'dynamic-intercepted-(..)(..)':\n            return '(..)(..)';\n        case 'catchall-intercepted-(.)':\n        case 'dynamic-intercepted-(.)':\n            return '(.)';\n        case 'catchall-intercepted-(..)':\n        case 'dynamic-intercepted-(..)':\n            return '(..)';\n        case 'catchall-intercepted-(...)':\n        case 'dynamic-intercepted-(...)':\n            return '(...)';\n        case 'catchall':\n        case 'dynamic':\n        case 'optional-catchall':\n        default:\n            return null;\n    }\n}\n\n//# sourceMappingURL=interception-prefix-from-param-type.js.map"],"names":[],"mappings":";;;;AAAO,SAAS,gCAAgC,SAAS;IACrD,OAAO;QACH,KAAK;QACL,KAAK;YACD,OAAO;QACX,KAAK;QACL,KAAK;YACD,OAAO;QACX,KAAK;QACL,KAAK;YACD,OAAO;QACX,KAAK;QACL,KAAK;YACD,OAAO;QACX,KAAK;QACL,KAAK;QACL,KAAK;QACL;YACI,OAAO;IACf;AACJ,EAEA,+DAA+D","ignoreList":[0]}},
    {"offset": {"line": 1187, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/shared/lib/router/utils/resolve-param-value.js"],"sourcesContent":["import { InvariantError } from '../../invariant-error';\nimport { interceptionPrefixFromParamType } from './interception-prefix-from-param-type';\n/**\n * Extracts the param value from a path segment, handling interception markers\n * based on the expected param type.\n *\n * @param pathSegment - The path segment to extract the value from\n * @param params - The current params object for resolving dynamic param references\n * @param paramType - The expected param type which may include interception marker info\n * @returns The extracted param value\n */ function getParamValueFromSegment(pathSegment, params, paramType) {\n    // If the segment is dynamic, resolve it from the params object\n    if (pathSegment.type === 'dynamic') {\n        return params[pathSegment.param.paramName];\n    }\n    // If the paramType indicates this is an intercepted param, strip the marker\n    // that matches the interception marker in the param type\n    const interceptionPrefix = interceptionPrefixFromParamType(paramType);\n    if (interceptionPrefix === pathSegment.interceptionMarker) {\n        return pathSegment.name.replace(pathSegment.interceptionMarker, '');\n    }\n    // For static segments, use the name\n    return pathSegment.name;\n}\n/**\n * Resolves a route parameter value from the route segments at the given depth.\n * This shared logic is used by both extractPathnameRouteParamSegmentsFromLoaderTree\n * and resolveRouteParamsFromTree.\n *\n * @param paramName - The parameter name to resolve\n * @param paramType - The parameter type (dynamic, catchall, etc.)\n * @param depth - The current depth in the route tree\n * @param route - The normalized route containing segments\n * @param params - The current params object (used to resolve embedded param references)\n * @param options - Configuration options\n * @returns The resolved parameter value, or undefined if it cannot be resolved\n */ export function resolveParamValue(paramName, paramType, depth, route, params) {\n    switch(paramType){\n        case 'catchall':\n        case 'optional-catchall':\n        case 'catchall-intercepted-(..)(..)':\n        case 'catchall-intercepted-(.)':\n        case 'catchall-intercepted-(..)':\n        case 'catchall-intercepted-(...)':\n            // For catchall routes, derive from pathname using depth to determine\n            // which segments to use\n            const processedSegments = [];\n            // Process segments to handle any embedded dynamic params\n            for(let index = depth; index < route.segments.length; index++){\n                const pathSegment = route.segments[index];\n                if (pathSegment.type === 'static') {\n                    let value = pathSegment.name;\n                    // For intercepted catch-all params, strip the marker from the first segment\n                    const interceptionPrefix = interceptionPrefixFromParamType(paramType);\n                    if (interceptionPrefix && index === depth && interceptionPrefix === pathSegment.interceptionMarker) {\n                        // Strip the interception marker from the value\n                        value = value.replace(pathSegment.interceptionMarker, '');\n                    }\n                    processedSegments.push(value);\n                } else {\n                    // If the segment is a param placeholder, check if we have its value\n                    if (!params.hasOwnProperty(pathSegment.param.paramName)) {\n                        // If the segment is an optional catchall, we can break out of the\n                        // loop because it's optional!\n                        if (pathSegment.param.paramType === 'optional-catchall') {\n                            break;\n                        }\n                        // Unknown param placeholder in pathname - can't derive full value\n                        return undefined;\n                    }\n                    // If the segment matches a param, use the param value\n                    // We don't encode values here as that's handled during retrieval.\n                    const paramValue = params[pathSegment.param.paramName];\n                    if (Array.isArray(paramValue)) {\n                        processedSegments.push(...paramValue);\n                    } else {\n                        processedSegments.push(paramValue);\n                    }\n                }\n            }\n            if (processedSegments.length > 0) {\n                return processedSegments;\n            } else if (paramType === 'optional-catchall') {\n                return undefined;\n            } else {\n                // We shouldn't be able to match a catchall segment without any path\n                // segments if it's not an optional catchall\n                throw Object.defineProperty(new InvariantError(`Unexpected empty path segments match for a route \"${route.pathname}\" with param \"${paramName}\" of type \"${paramType}\"`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E931\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        case 'dynamic':\n        case 'dynamic-intercepted-(..)(..)':\n        case 'dynamic-intercepted-(.)':\n        case 'dynamic-intercepted-(..)':\n        case 'dynamic-intercepted-(...)':\n            // For regular dynamic parameters, take the segment at this depth\n            if (depth < route.segments.length) {\n                const pathSegment = route.segments[depth];\n                // Check if the segment at this depth is a placeholder for an unknown param\n                if (pathSegment.type === 'dynamic' && !params.hasOwnProperty(pathSegment.param.paramName)) {\n                    // The segment is a placeholder like [category] and we don't have the value\n                    return undefined;\n                }\n                // If the segment matches a param, use the param value from params object\n                // Otherwise it's a static segment, just use it directly\n                // We don't encode values here as that's handled during retrieval\n                return getParamValueFromSegment(pathSegment, params, paramType);\n            }\n            return undefined;\n        default:\n            paramType;\n    }\n}\n\n//# sourceMappingURL=resolve-param-value.js.map"],"names":[],"mappings":";;;;AAAA;AACA;;;AACA;;;;;;;;CAQC,GAAG,SAAS,yBAAyB,WAAW,EAAE,MAAM,EAAE,SAAS;IAChE,+DAA+D;IAC/D,IAAI,YAAY,IAAI,KAAK,WAAW;QAChC,OAAO,MAAM,CAAC,YAAY,KAAK,CAAC,SAAS,CAAC;IAC9C;IACA,4EAA4E;IAC5E,yDAAyD;IACzD,MAAM,qBAAqB,IAAA,+QAA+B,EAAC;IAC3D,IAAI,uBAAuB,YAAY,kBAAkB,EAAE;QACvD,OAAO,YAAY,IAAI,CAAC,OAAO,CAAC,YAAY,kBAAkB,EAAE;IACpE;IACA,oCAAoC;IACpC,OAAO,YAAY,IAAI;AAC3B;AAaW,SAAS,kBAAkB,SAAS,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM;IAC5E,OAAO;QACH,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACD,qEAAqE;YACrE,wBAAwB;YACxB,MAAM,oBAAoB,EAAE;YAC5B,yDAAyD;YACzD,IAAI,IAAI,QAAQ,OAAO,QAAQ,MAAM,QAAQ,CAAC,MAAM,EAAE,QAAQ;gBAC1D,MAAM,cAAc,MAAM,QAAQ,CAAC,MAAM;gBACzC,IAAI,YAAY,IAAI,KAAK,UAAU;oBAC/B,IAAI,QAAQ,YAAY,IAAI;oBAC5B,4EAA4E;oBAC5E,MAAM,qBAAqB,IAAA,+QAA+B,EAAC;oBAC3D,IAAI,sBAAsB,UAAU,SAAS,uBAAuB,YAAY,kBAAkB,EAAE;wBAChG,+CAA+C;wBAC/C,QAAQ,MAAM,OAAO,CAAC,YAAY,kBAAkB,EAAE;oBAC1D;oBACA,kBAAkB,IAAI,CAAC;gBAC3B,OAAO;oBACH,oEAAoE;oBACpE,IAAI,CAAC,OAAO,cAAc,CAAC,YAAY,KAAK,CAAC,SAAS,GAAG;wBACrD,kEAAkE;wBAClE,8BAA8B;wBAC9B,IAAI,YAAY,KAAK,CAAC,SAAS,KAAK,qBAAqB;4BACrD;wBACJ;wBACA,kEAAkE;wBAClE,OAAO;oBACX;oBACA,sDAAsD;oBACtD,kEAAkE;oBAClE,MAAM,aAAa,MAAM,CAAC,YAAY,KAAK,CAAC,SAAS,CAAC;oBACtD,IAAI,MAAM,OAAO,CAAC,aAAa;wBAC3B,kBAAkB,IAAI,IAAI;oBAC9B,OAAO;wBACH,kBAAkB,IAAI,CAAC;oBAC3B;gBACJ;YACJ;YACA,IAAI,kBAAkB,MAAM,GAAG,GAAG;gBAC9B,OAAO;YACX,OAAO,IAAI,cAAc,qBAAqB;gBAC1C,OAAO;YACX,OAAO;gBACH,oEAAoE;gBACpE,4CAA4C;gBAC5C,MAAM,OAAO,cAAc,CAAC,IAAI,8MAAc,CAAC,CAAC,kDAAkD,EAAE,MAAM,QAAQ,CAAC,cAAc,EAAE,UAAU,WAAW,EAAE,UAAU,CAAC,CAAC,GAAG,qBAAqB;oBAC1L,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;YACJ;QACJ,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACD,iEAAiE;YACjE,IAAI,QAAQ,MAAM,QAAQ,CAAC,MAAM,EAAE;gBAC/B,MAAM,cAAc,MAAM,QAAQ,CAAC,MAAM;gBACzC,2EAA2E;gBAC3E,IAAI,YAAY,IAAI,KAAK,aAAa,CAAC,OAAO,cAAc,CAAC,YAAY,KAAK,CAAC,SAAS,GAAG;oBACvF,2EAA2E;oBAC3E,OAAO;gBACX;gBACA,yEAAyE;gBACzE,wDAAwD;gBACxD,iEAAiE;gBACjE,OAAO,yBAAyB,aAAa,QAAQ;YACzD;YACA,OAAO;QACX;YACI;IACR;AACJ,EAEA,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 1301, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/build/static-paths/app/extract-pathname-route-param-segments-from-loader-tree.js"],"sourcesContent":["import { parseAppRouteSegment } from '../../../shared/lib/router/routes/app';\nimport { parseLoaderTree } from '../../../shared/lib/router/utils/parse-loader-tree';\nimport { resolveParamValue } from '../../../shared/lib/router/utils/resolve-param-value';\n/**\n * Validates that the static segments in currentPath match the corresponding\n * segments in targetSegments. This ensures we only extract dynamic parameters\n * that are part of the target pathname structure.\n *\n * Segments are compared literally - interception markers like \"(.)photo\" are\n * part of the pathname and must match exactly.\n *\n * @example\n * // Matching paths\n * currentPath: ['blog', '(.)photo']\n * targetSegments: ['blog', '(.)photo', '[id]']\n *  Returns true (both static segments match exactly)\n *\n * @example\n * // Non-matching paths\n * currentPath: ['blog', '(.)photo']\n * targetSegments: ['blog', 'photo', '[id]']\n *  Returns false (segments don't match - marker is part of pathname)\n *\n * @param currentPath - The accumulated path segments from the loader tree\n * @param targetSegments - The target pathname split into segments\n * @returns true if all static segments match, false otherwise\n */ function validatePrefixMatch(currentPath, route) {\n    for(let i = 0; i < currentPath.length; i++){\n        const pathSegment = currentPath[i];\n        const targetPathSegment = route.segments[i];\n        // Type mismatch - one is static, one is dynamic\n        if (pathSegment.type !== targetPathSegment.type) {\n            return false;\n        }\n        // One has an interception marker, the other doesn't.\n        if (pathSegment.interceptionMarker !== targetPathSegment.interceptionMarker) {\n            return false;\n        }\n        // Both are static but names don't match\n        if (pathSegment.type === 'static' && targetPathSegment.type === 'static' && pathSegment.name !== targetPathSegment.name) {\n            return false;\n        } else if (pathSegment.type === 'dynamic' && targetPathSegment.type === 'dynamic' && pathSegment.param.paramType !== targetPathSegment.param.paramType && pathSegment.param.paramName !== targetPathSegment.param.paramName) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Extracts pathname route param segments from a loader tree and resolves\n * parameter values from static segments in the route.\n *\n * @param loaderTree - The loader tree structure containing route hierarchy\n * @param route - The target route to match against\n * @returns Object containing pathname route param segments and resolved params\n */ export function extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route) {\n    const pathnameRouteParamSegments = [];\n    const params = {};\n    // BFS traversal with depth and path tracking\n    const queue = [\n        {\n            tree: loaderTree,\n            depth: 0,\n            currentPath: []\n        }\n    ];\n    while(queue.length > 0){\n        const { tree, depth, currentPath } = queue.shift();\n        const { segment, parallelRoutes } = parseLoaderTree(tree);\n        // Build the path for the current node\n        let updatedPath = currentPath;\n        let nextDepth = depth;\n        const appSegment = parseAppRouteSegment(segment);\n        // Only add to path if it's a real segment that appears in the URL\n        // Route groups and parallel markers don't contribute to URL pathname\n        if (appSegment && appSegment.type !== 'route-group' && appSegment.type !== 'parallel-route') {\n            updatedPath = [\n                ...currentPath,\n                appSegment\n            ];\n            nextDepth = depth + 1;\n        }\n        // Check if this segment has a param and matches the target pathname at this depth\n        if ((appSegment == null ? void 0 : appSegment.type) === 'dynamic') {\n            const { paramName, paramType } = appSegment.param;\n            // Check if this segment is at the correct depth in the target pathname\n            // A segment matches if:\n            // 1. There's a dynamic segment at this depth in the pathname\n            // 2. The parameter names match (e.g., [id] matches [id], not [category])\n            // 3. The static segments leading up to this point match (prefix check)\n            if (depth < route.segments.length) {\n                const targetSegment = route.segments[depth];\n                // Match if the target pathname has a dynamic segment at this depth\n                if (targetSegment.type === 'dynamic') {\n                    // Check that parameter names match exactly\n                    // This prevents [category] from matching against /[id]\n                    if (paramName !== targetSegment.param.paramName) {\n                        continue; // Different param names, skip this segment\n                    }\n                    // Validate that the path leading up to this dynamic segment matches\n                    // the target pathname. This prevents false matches like extracting\n                    // [slug] from \"/news/[slug]\" when the tree has \"/blog/[slug]\"\n                    if (validatePrefixMatch(currentPath, route)) {\n                        pathnameRouteParamSegments.push({\n                            name: segment,\n                            paramName,\n                            paramType\n                        });\n                    }\n                }\n            }\n            // Resolve parameter value if it's not already known.\n            if (!params.hasOwnProperty(paramName)) {\n                const paramValue = resolveParamValue(paramName, paramType, depth, route, params);\n                if (paramValue !== undefined) {\n                    params[paramName] = paramValue;\n                }\n            }\n        }\n        // Continue traversing all parallel routes to find matching segments\n        for (const parallelRoute of Object.values(parallelRoutes)){\n            queue.push({\n                tree: parallelRoute,\n                depth: nextDepth,\n                currentPath: updatedPath\n            });\n        }\n    }\n    return {\n        pathnameRouteParamSegments,\n        params\n    };\n}\n\n//# sourceMappingURL=extract-pathname-route-param-segments-from-loader-tree.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1437, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/build/static-paths/utils.js"],"sourcesContent":["import { isAppPageRouteModule } from '../../server/route-modules/checks';\nimport { parseAppRouteSegment } from '../../shared/lib/router/routes/app';\nimport { parseLoaderTree } from '../../shared/lib/router/utils/parse-loader-tree';\nimport { extractPathnameRouteParamSegmentsFromLoaderTree } from './app/extract-pathname-route-param-segments-from-loader-tree';\nimport { resolveParamValue } from '../../shared/lib/router/utils/resolve-param-value';\n/**\n * Encodes a parameter value using the provided encoder.\n *\n * @param value - The value to encode.\n * @param encoder - The encoder to use.\n * @returns The encoded value.\n */ export function encodeParam(value, encoder) {\n    let replaceValue;\n    if (Array.isArray(value)) {\n        replaceValue = value.map(encoder).join('/');\n    } else {\n        replaceValue = encoder(value);\n    }\n    return replaceValue;\n}\n/**\n * Normalizes a pathname to a consistent format.\n *\n * @param pathname - The pathname to normalize.\n * @returns The normalized pathname.\n */ export function normalizePathname(pathname) {\n    return pathname.replace(/\\\\/g, '/').replace(/(?!^)\\/$/, '');\n}\n/**\n * Extracts segments that contribute to the pathname by traversing the loader tree\n * based on the route module type.\n *\n * @param routeModule - The app route module (page or route handler)\n * @param segments - Array of AppSegment objects collected from the route\n * @param page - The target pathname to match against, INCLUDING interception\n *               markers (e.g., \"/blog/[slug]\", \"/(.)photo/[id]\")\n * @returns Array of segments with param info that contribute to the pathname\n */ export function extractPathnameRouteParamSegments(routeModule, segments, route) {\n    // For AppPageRouteModule, use the loaderTree traversal approach\n    if (isAppPageRouteModule(routeModule)) {\n        const { pathnameRouteParamSegments } = extractPathnameRouteParamSegmentsFromLoaderTree(routeModule.userland.loaderTree, route);\n        return pathnameRouteParamSegments;\n    }\n    return extractPathnameRouteParamSegmentsFromSegments(segments);\n}\nexport function extractPathnameRouteParamSegmentsFromSegments(segments) {\n    // TODO: should we consider what values are already present in the page?\n    // For AppRouteRouteModule, filter the segments array to get the route params\n    // that contribute to the pathname.\n    const result = [];\n    for (const segment of segments){\n        // Skip segments without param info.\n        if (!segment.paramName || !segment.paramType) continue;\n        // Collect all the route param keys that contribute to the pathname.\n        result.push({\n            name: segment.name,\n            paramName: segment.paramName,\n            paramType: segment.paramType\n        });\n    }\n    return result;\n}\n/**\n * Resolves all route parameters from the loader tree. This function uses\n * tree-based traversal to correctly handle the hierarchical structure of routes\n * and accurately determine parameter values based on their depth in the tree.\n *\n * This processes both regular route parameters (from the main children route) and\n * parallel route parameters (from slots like @modal, @sidebar).\n *\n * Unlike interpolateParallelRouteParams (which has a complete URL at runtime),\n * this build-time function determines which route params are unknown.\n * The pathname may contain placeholders like [slug], making it incomplete.\n *\n * @param loaderTree - The loader tree structure containing route hierarchy\n * @param params - The current route parameters object (will be mutated)\n * @param route - The current route being processed\n * @param fallbackRouteParams - Array of fallback route parameters (will be mutated)\n */ export function resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams) {\n    // Stack-based traversal with depth tracking\n    const stack = [\n        {\n            tree: loaderTree,\n            depth: 0\n        }\n    ];\n    while(stack.length > 0){\n        const { tree, depth } = stack.pop();\n        const { segment, parallelRoutes } = parseLoaderTree(tree);\n        const appSegment = parseAppRouteSegment(segment);\n        // If this segment is a route parameter, then we should process it if it's\n        // not already known and is not already marked as a fallback route param.\n        if ((appSegment == null ? void 0 : appSegment.type) === 'dynamic' && !params.hasOwnProperty(appSegment.param.paramName) && !fallbackRouteParams.some((param)=>param.paramName === appSegment.param.paramName)) {\n            const { paramName, paramType } = appSegment.param;\n            const paramValue = resolveParamValue(paramName, paramType, depth, route, params);\n            if (paramValue !== undefined) {\n                params[paramName] = paramValue;\n            } else if (paramType !== 'optional-catchall') {\n                // If we couldn't resolve the param, mark it as a fallback\n                fallbackRouteParams.push({\n                    paramName,\n                    paramType\n                });\n            }\n        }\n        // Calculate next depth - increment if this is not a route group and not empty\n        let nextDepth = depth;\n        if (appSegment && appSegment.type !== 'route-group' && appSegment.type !== 'parallel-route') {\n            nextDepth++;\n        }\n        // Add all parallel routes to the stack for processing.\n        for (const parallelRoute of Object.values(parallelRoutes)){\n            stack.push({\n                tree: parallelRoute,\n                depth: nextDepth\n            });\n        }\n    }\n}\n\n//# sourceMappingURL=utils.js.map"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAOW,SAAS,YAAY,KAAK,EAAE,OAAO;IAC1C,IAAI;IACJ,IAAI,MAAM,OAAO,CAAC,QAAQ;QACtB,eAAe,MAAM,GAAG,CAAC,SAAS,IAAI,CAAC;IAC3C,OAAO;QACH,eAAe,QAAQ;IAC3B;IACA,OAAO;AACX;AAMW,SAAS,kBAAkB,QAAQ;IAC1C,OAAO,SAAS,OAAO,CAAC,OAAO,KAAK,OAAO,CAAC,YAAY;AAC5D;AAUW,SAAS,kCAAkC,WAAW,EAAE,QAAQ,EAAE,KAAK;IAC9E,gEAAgE;IAChE,IAAI,IAAA,qNAAoB,EAAC,cAAc;QACnC,MAAM,EAAE,0BAA0B,EAAE,GAAG,IAAA,0TAA+C,EAAC,YAAY,QAAQ,CAAC,UAAU,EAAE;QACxH,OAAO;IACX;IACA,OAAO,8CAA8C;AACzD;AACO,SAAS,8CAA8C,QAAQ;IAClE,wEAAwE;IACxE,6EAA6E;IAC7E,mCAAmC;IACnC,MAAM,SAAS,EAAE;IACjB,KAAK,MAAM,WAAW,SAAS;QAC3B,oCAAoC;QACpC,IAAI,CAAC,QAAQ,SAAS,IAAI,CAAC,QAAQ,SAAS,EAAE;QAC9C,oEAAoE;QACpE,OAAO,IAAI,CAAC;YACR,MAAM,QAAQ,IAAI;YAClB,WAAW,QAAQ,SAAS;YAC5B,WAAW,QAAQ,SAAS;QAChC;IACJ;IACA,OAAO;AACX;AAiBW,SAAS,2BAA2B,UAAU,EAAE,MAAM,EAAE,KAAK,EAAE,mBAAmB;IACzF,4CAA4C;IAC5C,MAAM,QAAQ;QACV;YACI,MAAM;YACN,OAAO;QACX;KACH;IACD,MAAM,MAAM,MAAM,GAAG,EAAE;QACnB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,GAAG;QACjC,MAAM,EAAE,OAAO,EAAE,cAAc,EAAE,GAAG,IAAA,uOAAe,EAAC;QACpD,MAAM,aAAa,IAAA,yNAAoB,EAAC;QACxC,0EAA0E;QAC1E,yEAAyE;QACzE,IAAI,CAAC,cAAc,OAAO,KAAK,IAAI,WAAW,IAAI,MAAM,aAAa,CAAC,OAAO,cAAc,CAAC,WAAW,KAAK,CAAC,SAAS,KAAK,CAAC,oBAAoB,IAAI,CAAC,CAAC,QAAQ,MAAM,SAAS,KAAK,WAAW,KAAK,CAAC,SAAS,GAAG;YAC3M,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,WAAW,KAAK;YACjD,MAAM,aAAa,IAAA,2OAAiB,EAAC,WAAW,WAAW,OAAO,OAAO;YACzE,IAAI,eAAe,WAAW;gBAC1B,MAAM,CAAC,UAAU,GAAG;YACxB,OAAO,IAAI,cAAc,qBAAqB;gBAC1C,0DAA0D;gBAC1D,oBAAoB,IAAI,CAAC;oBACrB;oBACA;gBACJ;YACJ;QACJ;QACA,8EAA8E;QAC9E,IAAI,YAAY;QAChB,IAAI,cAAc,WAAW,IAAI,KAAK,iBAAiB,WAAW,IAAI,KAAK,kBAAkB;YACzF;QACJ;QACA,uDAAuD;QACvD,KAAK,MAAM,iBAAiB,OAAO,MAAM,CAAC,gBAAgB;YACtD,MAAM,IAAI,CAAC;gBACP,MAAM;gBACN,OAAO;YACX;QACJ;IACJ;AACJ,EAEA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 1541, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/app-render/get-short-dynamic-param-type.js"],"sourcesContent":["export const dynamicParamTypes = {\n    catchall: 'c',\n    'catchall-intercepted-(..)(..)': 'ci(..)(..)',\n    'catchall-intercepted-(.)': 'ci(.)',\n    'catchall-intercepted-(..)': 'ci(..)',\n    'catchall-intercepted-(...)': 'ci(...)',\n    'optional-catchall': 'oc',\n    dynamic: 'd',\n    'dynamic-intercepted-(..)(..)': 'di(..)(..)',\n    'dynamic-intercepted-(.)': 'di(.)',\n    'dynamic-intercepted-(..)': 'di(..)',\n    'dynamic-intercepted-(...)': 'di(...)'\n};\n\n//# sourceMappingURL=get-short-dynamic-param-type.js.map"],"names":[],"mappings":";;;;AAAO,MAAM,oBAAoB;IAC7B,UAAU;IACV,iCAAiC;IACjC,4BAA4B;IAC5B,6BAA6B;IAC7B,8BAA8B;IAC9B,qBAAqB;IACrB,SAAS;IACT,gCAAgC;IAChC,2BAA2B;IAC3B,4BAA4B;IAC5B,6BAA6B;AACjC,GAEA,wDAAwD","ignoreList":[0]}},
    {"offset": {"line": 1562, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/request/fallback-params.js"],"sourcesContent":["import { resolveRouteParamsFromTree } from '../../build/static-paths/utils';\nimport { dynamicParamTypes } from '../app-render/get-short-dynamic-param-type';\nimport { parseAppRoute } from '../../shared/lib/router/routes/app';\nimport { extractPathnameRouteParamSegmentsFromLoaderTree } from '../../build/static-paths/app/extract-pathname-route-param-segments-from-loader-tree';\n/**\n * Creates an opaque fallback route params object from the fallback route params.\n *\n * @param fallbackRouteParams the fallback route params\n * @returns the opaque fallback route params\n */ export function createOpaqueFallbackRouteParams(fallbackRouteParams) {\n    // If there are no fallback route params, we can return early.\n    if (fallbackRouteParams.length === 0) return null;\n    // As we're creating unique keys for each of the dynamic route params, we only\n    // need to generate a unique ID once per request because each of the keys will\n    // be also be unique.\n    const uniqueID = Math.random().toString(16).slice(2);\n    const keys = new Map();\n    // Generate a unique key for the fallback route param, if this key is found\n    // in the static output, it represents a bug in cache components.\n    for (const { paramName, paramType } of fallbackRouteParams){\n        keys.set(paramName, [\n            `%%drp:${paramName}:${uniqueID}%%`,\n            dynamicParamTypes[paramType]\n        ]);\n    }\n    return keys;\n}\n/**\n * Gets the fallback route params for a given page. This is an expensive\n * operation because it requires parsing the loader tree to extract the fallback\n * route params.\n *\n * @param page the page\n * @param routeModule the route module\n * @returns the opaque fallback route params\n */ export function getFallbackRouteParams(page, routeModule) {\n    const route = parseAppRoute(page, true);\n    // Extract the pathname-contributing segments from the loader tree. This\n    // mirrors the logic in buildAppStaticPaths where we determine which segments\n    // actually contribute to the pathname.\n    const { pathnameRouteParamSegments, params } = extractPathnameRouteParamSegmentsFromLoaderTree(routeModule.userland.loaderTree, route);\n    // Create fallback route params for the pathname segments.\n    const fallbackRouteParams = pathnameRouteParamSegments.map(({ paramName, paramType })=>({\n            paramName,\n            paramType\n        }));\n    // Resolve route params from the loader tree. This mutates the\n    // fallbackRouteParams array to add any route params that are\n    // unknown at request time.\n    //\n    // The page parameter contains placeholders like [slug], which helps\n    // resolveRouteParamsFromTree determine which params are unknown.\n    resolveRouteParamsFromTree(routeModule.userland.loaderTree, params, route, fallbackRouteParams // Will be mutated to add route params\n    );\n    // Convert the fallback route params to an opaque format that can be safely\n    // used in the postponed state without exposing implementation details.\n    return createOpaqueFallbackRouteParams(fallbackRouteParams);\n}\n\n//# sourceMappingURL=fallback-params.js.map"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAMW,SAAS,gCAAgC,mBAAmB;IACnE,8DAA8D;IAC9D,IAAI,oBAAoB,MAAM,KAAK,GAAG,OAAO;IAC7C,8EAA8E;IAC9E,8EAA8E;IAC9E,qBAAqB;IACrB,MAAM,WAAW,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,KAAK,CAAC;IAClD,MAAM,OAAO,IAAI;IACjB,2EAA2E;IAC3E,iEAAiE;IACjE,KAAK,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,IAAI,oBAAoB;QACvD,KAAK,GAAG,CAAC,WAAW;YAChB,CAAC,MAAM,EAAE,UAAU,CAAC,EAAE,SAAS,EAAE,CAAC;YAClC,iPAAiB,CAAC,UAAU;SAC/B;IACL;IACA,OAAO;AACX;AASW,SAAS,uBAAuB,IAAI,EAAE,WAAW;IACxD,MAAM,QAAQ,IAAA,kNAAa,EAAC,MAAM;IAClC,wEAAwE;IACxE,6EAA6E;IAC7E,uCAAuC;IACvC,MAAM,EAAE,0BAA0B,EAAE,MAAM,EAAE,GAAG,IAAA,0TAA+C,EAAC,YAAY,QAAQ,CAAC,UAAU,EAAE;IAChI,0DAA0D;IAC1D,MAAM,sBAAsB,2BAA2B,GAAG,CAAC,CAAC,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,CAAC;YAChF;YACA;QACJ,CAAC;IACL,8DAA8D;IAC9D,6DAA6D;IAC7D,2BAA2B;IAC3B,EAAE;IACF,oEAAoE;IACpE,iEAAiE;IACjE,IAAA,wNAA0B,EAAC,YAAY,QAAQ,CAAC,UAAU,EAAE,QAAQ,OAAO,oBAAoB,sCAAsC;;IAErI,2EAA2E;IAC3E,uEAAuE;IACvE,OAAO,gCAAgC;AAC3C,EAEA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 1621, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/app-render/manifests-singleton.js"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error';\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths';\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix';\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix';\nimport { workAsyncStorage } from './work-async-storage.external';\n// This is a global singleton that is, among other things, also used to\n// encode/decode bound args of server function closures. This can't be using a\n// AsyncLocalStorage as it might happen at the module level.\nconst MANIFESTS_SINGLETON = Symbol.for('next.server.manifests');\nconst globalThisWithManifests = globalThis;\nfunction createProxiedClientReferenceManifest(clientReferenceManifestsPerRoute) {\n    const createMappingProxy = (prop)=>{\n        return new Proxy({}, {\n            get (_, id) {\n                const workStore = workAsyncStorage.getStore();\n                if (workStore) {\n                    const currentManifest = clientReferenceManifestsPerRoute.get(workStore.route);\n                    if (currentManifest == null ? void 0 : currentManifest[prop][id]) {\n                        return currentManifest[prop][id];\n                    }\n                    // In development, we also check all other manifests to see if the\n                    // module exists there. This is to support a scenario where React's\n                    // I/O tracking (dev-only) creates a connection from one page to\n                    // another through an emitted async I/O node that references client\n                    // components from the other page, e.g. in owner props.\n                    // TODO: Maybe we need to add a `debugBundlerConfig` option to React\n                    // to avoid this workaround. The current workaround has the\n                    // disadvantage that one might accidentally or intentionally share\n                    // client references across pages (e.g. by storing them in a global\n                    // variable), which would then only be caught in production.\n                    if (process.env.NODE_ENV !== 'production') {\n                        for (const [route, manifest] of clientReferenceManifestsPerRoute){\n                            if (route === workStore.route) {\n                                continue;\n                            }\n                            const entry = manifest[prop][id];\n                            if (entry !== undefined) {\n                                return entry;\n                            }\n                        }\n                    }\n                } else {\n                    // If there's no work store defined, we can assume that a client\n                    // reference manifest is needed during module evaluation, e.g. to\n                    // create a server function using a higher-order function. This\n                    // might also use client components which need to be serialized by\n                    // Flight, and therefore client references need to be resolvable. In\n                    // that case we search all page manifests to find the module.\n                    for (const manifest of clientReferenceManifestsPerRoute.values()){\n                        const entry = manifest[prop][id];\n                        if (entry !== undefined) {\n                            return entry;\n                        }\n                    }\n                }\n                return undefined;\n            }\n        });\n    };\n    const mappingProxies = new Map();\n    return new Proxy({}, {\n        get (_, prop) {\n            const workStore = workAsyncStorage.getStore();\n            switch(prop){\n                case 'moduleLoading':\n                case 'entryCSSFiles':\n                case 'entryJSFiles':\n                    {\n                        if (!workStore) {\n                            throw Object.defineProperty(new InvariantError(`Cannot access \"${prop}\" without a work store.`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E952\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        const currentManifest = clientReferenceManifestsPerRoute.get(workStore.route);\n                        if (!currentManifest) {\n                            throw Object.defineProperty(new InvariantError(`The client reference manifest for route \"${workStore.route}\" does not exist.`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E951\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        return currentManifest[prop];\n                    }\n                case 'clientModules':\n                case 'rscModuleMapping':\n                case 'edgeRscModuleMapping':\n                case 'ssrModuleMapping':\n                case 'edgeSSRModuleMapping':\n                    {\n                        let proxy = mappingProxies.get(prop);\n                        if (!proxy) {\n                            proxy = createMappingProxy(prop);\n                            mappingProxies.set(prop, proxy);\n                        }\n                        return proxy;\n                    }\n                default:\n                    {\n                        throw Object.defineProperty(new InvariantError(`This is a proxied client reference manifest. The property \"${String(prop)}\" is not handled.`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E953\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n            }\n        }\n    });\n}\n/**\n * This function creates a Flight-acceptable server module map proxy from our\n * Server Reference Manifest similar to our client module map. This is because\n * our manifest contains a lot of internal Next.js data that are relevant to the\n * runtime, workers, etc. that React doesn't need to know.\n */ function createServerModuleMap() {\n    return new Proxy({}, {\n        get: (_, id)=>{\n            var _getServerActionsManifest__id, _getServerActionsManifest_;\n            const workers = (_getServerActionsManifest_ = getServerActionsManifest()[process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node']) == null ? void 0 : (_getServerActionsManifest__id = _getServerActionsManifest_[id]) == null ? void 0 : _getServerActionsManifest__id.workers;\n            if (!workers) {\n                return undefined;\n            }\n            const workStore = workAsyncStorage.getStore();\n            let workerEntry;\n            if (workStore) {\n                workerEntry = workers[normalizeWorkerPageName(workStore.page)];\n            } else {\n                // If there's no work store defined, we can assume that a server\n                // module map is needed during module evaluation, e.g. to create a\n                // server action using a higher-order function. Therefore it should be\n                // safe to return any entry from the manifest that matches the action\n                // ID. They all refer to the same module ID, which must also exist in\n                // the current page bundle. TODO: This is currently not guaranteed in\n                // Turbopack, and needs to be fixed.\n                workerEntry = Object.values(workers).at(0);\n            }\n            if (!workerEntry) {\n                return undefined;\n            }\n            const { moduleId, async } = workerEntry;\n            return {\n                id: moduleId,\n                name: id,\n                chunks: [],\n                async\n            };\n        }\n    });\n}\n/**\n * The flight entry loader keys actions by bundlePath. bundlePath corresponds\n * with the relative path (including 'app') to the page entrypoint.\n */ function normalizeWorkerPageName(pageName) {\n    if (pathHasPrefix(pageName, 'app')) {\n        return pageName;\n    }\n    return 'app' + pageName;\n}\n/**\n * Converts a bundlePath (relative path to the entrypoint) to a routable page\n * name.\n */ function denormalizeWorkerPageName(bundlePath) {\n    return normalizeAppPath(removePathPrefix(bundlePath, 'app'));\n}\n/**\n * Checks if the requested action has a worker for the current page.\n * If not, it returns the first worker that has a handler for the action.\n */ export function selectWorkerForForwarding(actionId, pageName) {\n    var _serverActionsManifest__actionId;\n    const serverActionsManifest = getServerActionsManifest();\n    const workers = (_serverActionsManifest__actionId = serverActionsManifest[process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'][actionId]) == null ? void 0 : _serverActionsManifest__actionId.workers;\n    // There are no workers to handle this action, nothing to forward to.\n    if (!workers) {\n        return;\n    }\n    // If there is an entry for the current page, we don't need to forward.\n    if (workers[normalizeWorkerPageName(pageName)]) {\n        return;\n    }\n    // Otherwise, grab the first worker that has a handler for this action id.\n    return denormalizeWorkerPageName(Object.keys(workers)[0]);\n}\nexport function setManifestsSingleton({ page, clientReferenceManifest, serverActionsManifest }) {\n    const existingSingleton = globalThisWithManifests[MANIFESTS_SINGLETON];\n    if (existingSingleton) {\n        existingSingleton.clientReferenceManifestsPerRoute.set(normalizeAppPath(page), clientReferenceManifest);\n        existingSingleton.serverActionsManifest = serverActionsManifest;\n    } else {\n        const clientReferenceManifestsPerRoute = new Map([\n            [\n                normalizeAppPath(page),\n                clientReferenceManifest\n            ]\n        ]);\n        const proxiedClientReferenceManifest = createProxiedClientReferenceManifest(clientReferenceManifestsPerRoute);\n        globalThisWithManifests[MANIFESTS_SINGLETON] = {\n            clientReferenceManifestsPerRoute,\n            proxiedClientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap()\n        };\n    }\n}\nfunction getManifestsSingleton() {\n    const manifestSingleton = globalThisWithManifests[MANIFESTS_SINGLETON];\n    if (!manifestSingleton) {\n        throw Object.defineProperty(new InvariantError('The manifests singleton was not initialized.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E950\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return manifestSingleton;\n}\nexport function getClientReferenceManifest() {\n    return getManifestsSingleton().proxiedClientReferenceManifest;\n}\nexport function getServerActionsManifest() {\n    return getManifestsSingleton().serverActionsManifest;\n}\nexport function getServerModuleMap() {\n    return getManifestsSingleton().serverModuleMap;\n}\n\n//# sourceMappingURL=manifests-singleton.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1863, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/shared/lib/router/utils/html-bots.js"],"sourcesContent":["// This regex contains the bots that we need to do a blocking render for and can't safely stream the response\n// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.\n// Note: The pattern [\\w-]+-Google captures all Google crawlers with \"-Google\" suffix (e.g., Mediapartners-Google, AdsBot-Google, Storebot-Google)\n// as well as crawlers starting with \"Google-\" (e.g., Google-PageRenderer, Google-InspectionTool)\nexport const HTML_LIMITED_BOT_UA_RE = /[\\w-]+-Google|Google-[\\w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i;\n\n//# sourceMappingURL=html-bots.js.map"],"names":[],"mappings":"AAAA,6GAA6G;AAC7G,sKAAsK;AACtK,kJAAkJ;AAClJ,iGAAiG;;;;;AAC1F,MAAM,yBAAyB,uTAEtC,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 1876, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js"],"sourcesContent":["import { HTML_LIMITED_BOT_UA_RE } from './html-bots';\n// Bot crawler that will spin up a headless browser and execute JS.\n// Only the main Googlebot search crawler executes JavaScript, not other Google crawlers.\n// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers\n// This regex specifically matches \"Googlebot\" but NOT \"Mediapartners-Google\", \"AdsBot-Google\", etc.\nconst HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i;\nexport const HTML_LIMITED_BOT_UA_RE_STRING = HTML_LIMITED_BOT_UA_RE.source;\nexport { HTML_LIMITED_BOT_UA_RE };\nfunction isDomBotUA(userAgent) {\n    return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent);\n}\nfunction isHtmlLimitedBotUA(userAgent) {\n    return HTML_LIMITED_BOT_UA_RE.test(userAgent);\n}\nexport function isBot(userAgent) {\n    return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent);\n}\nexport function getBotType(userAgent) {\n    if (isDomBotUA(userAgent)) {\n        return 'dom';\n    }\n    if (isHtmlLimitedBotUA(userAgent)) {\n        return 'html';\n    }\n    return undefined;\n}\n\n//# sourceMappingURL=is-bot.js.map"],"names":[],"mappings":";;;;;;;;AAAA;;AACA,mEAAmE;AACnE,yFAAyF;AACzF,4FAA4F;AAC5F,oGAAoG;AACpG,MAAM,6BAA6B;AAC5B,MAAM,gCAAgC,mOAAsB,CAAC,MAAM;;AAE1E,SAAS,WAAW,SAAS;IACzB,OAAO,2BAA2B,IAAI,CAAC;AAC3C;AACA,SAAS,mBAAmB,SAAS;IACjC,OAAO,mOAAsB,CAAC,IAAI,CAAC;AACvC;AACO,SAAS,MAAM,SAAS;IAC3B,OAAO,WAAW,cAAc,mBAAmB;AACvD;AACO,SAAS,WAAW,SAAS;IAChC,IAAI,WAAW,YAAY;QACvB,OAAO;IACX;IACA,IAAI,mBAAmB,YAAY;QAC/B,OAAO;IACX;IACA,OAAO;AACX,EAEA,kCAAkC","ignoreList":[0]}},
    {"offset": {"line": 1915, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/lib/streaming-metadata.js"],"sourcesContent":["import { getBotType, HTML_LIMITED_BOT_UA_RE_STRING } from '../../shared/lib/router/utils/is-bot';\nexport function shouldServeStreamingMetadata(userAgent, htmlLimitedBots) {\n    const blockingMetadataUARegex = new RegExp(htmlLimitedBots || HTML_LIMITED_BOT_UA_RE_STRING, 'i');\n    // Only block metadata for HTML-limited bots\n    if (userAgent && blockingMetadataUARegex.test(userAgent)) {\n        return false;\n    }\n    return true;\n}\n// When the request UA is a html-limited bot, we should do a dynamic render.\n// In this case, postpone state is not sent.\nexport function isHtmlBotRequest(req) {\n    const ua = req.headers['user-agent'] || '';\n    const botType = getBotType(ua);\n    return botType === 'html';\n}\n\n//# sourceMappingURL=streaming-metadata.js.map"],"names":[],"mappings":";;;;;;AAAA;;AACO,SAAS,6BAA6B,SAAS,EAAE,eAAe;IACnE,MAAM,0BAA0B,IAAI,OAAO,mBAAmB,uPAA6B,EAAE;IAC7F,4CAA4C;IAC5C,IAAI,aAAa,wBAAwB,IAAI,CAAC,YAAY;QACtD,OAAO;IACX;IACA,OAAO;AACX;AAGO,SAAS,iBAAiB,GAAG;IAChC,MAAM,KAAK,IAAI,OAAO,CAAC,aAAa,IAAI;IACxC,MAAM,UAAU,IAAA,oOAAU,EAAC;IAC3B,OAAO,YAAY;AACvB,EAEA,8CAA8C","ignoreList":[0]}},
    {"offset": {"line": 1940, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/lib/server-action-request-meta.js"],"sourcesContent":["import { ACTION_HEADER } from '../../client/components/app-router-headers';\nexport function getServerActionRequestMetadata(req) {\n    let actionId;\n    let contentType;\n    if (req.headers instanceof Headers) {\n        actionId = req.headers.get(ACTION_HEADER) ?? null;\n        contentType = req.headers.get('content-type');\n    } else {\n        actionId = req.headers[ACTION_HEADER] ?? null;\n        contentType = req.headers['content-type'] ?? null;\n    }\n    // We don't actually support URL encoded actions, and the action handler will bail out if it sees one.\n    // But we still want it to flow through to the action handler, to prevent changes in behavior when a regular\n    // page component tries to handle a POST.\n    const isURLEncodedAction = Boolean(req.method === 'POST' && contentType === 'application/x-www-form-urlencoded');\n    const isMultipartAction = Boolean(req.method === 'POST' && (contentType == null ? void 0 : contentType.startsWith('multipart/form-data')));\n    const isFetchAction = Boolean(actionId !== undefined && typeof actionId === 'string' && req.method === 'POST');\n    const isPossibleServerAction = Boolean(isFetchAction || isURLEncodedAction || isMultipartAction);\n    return {\n        actionId,\n        isURLEncodedAction,\n        isMultipartAction,\n        isFetchAction,\n        isPossibleServerAction\n    };\n}\nexport function getIsPossibleServerAction(req) {\n    return getServerActionRequestMetadata(req).isPossibleServerAction;\n}\n\n//# sourceMappingURL=server-action-request-meta.js.map"],"names":[],"mappings":";;;;;;AAAA;;AACO,SAAS,+BAA+B,GAAG;IAC9C,IAAI;IACJ,IAAI;IACJ,IAAI,IAAI,OAAO,YAAY,SAAS;QAChC,WAAW,IAAI,OAAO,CAAC,GAAG,CAAC,0NAAa,KAAK;QAC7C,cAAc,IAAI,OAAO,CAAC,GAAG,CAAC;IAClC,OAAO;QACH,WAAW,IAAI,OAAO,CAAC,0NAAa,CAAC,IAAI;QACzC,cAAc,IAAI,OAAO,CAAC,eAAe,IAAI;IACjD;IACA,sGAAsG;IACtG,4GAA4G;IAC5G,yCAAyC;IACzC,MAAM,qBAAqB,QAAQ,IAAI,MAAM,KAAK,UAAU,gBAAgB;IAC5E,MAAM,oBAAoB,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,eAAe,OAAO,KAAK,IAAI,YAAY,UAAU,CAAC,sBAAsB;IACxI,MAAM,gBAAgB,QAAQ,aAAa,aAAa,OAAO,aAAa,YAAY,IAAI,MAAM,KAAK;IACvG,MAAM,yBAAyB,QAAQ,iBAAiB,sBAAsB;IAC9E,OAAO;QACH;QACA;QACA;QACA;QACA;IACJ;AACJ;AACO,SAAS,0BAA0B,GAAG;IACzC,OAAO,+BAA+B,KAAK,sBAAsB;AACrE,EAEA,sDAAsD","ignoreList":[0]}},
    {"offset": {"line": 1980, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/lib/fallback.js"],"sourcesContent":["/**\n * Describes the different fallback modes that a given page can have.\n */ export var FallbackMode = /*#__PURE__*/ function(FallbackMode) {\n    /**\n   * A BLOCKING_STATIC_RENDER fallback will block the request until the page is\n   * generated. No fallback page will be rendered, and users will have to wait\n   * to render the page.\n   */ FallbackMode[\"BLOCKING_STATIC_RENDER\"] = \"BLOCKING_STATIC_RENDER\";\n    /**\n   * When set to PRERENDER, a fallback page will be sent to users in place of\n   * forcing them to wait for the page to be generated. This allows the user to\n   * see a rendered page earlier.\n   */ FallbackMode[\"PRERENDER\"] = \"PRERENDER\";\n    /**\n   * When set to NOT_FOUND, pages that are not already prerendered will result\n   * in a not found response.\n   */ FallbackMode[\"NOT_FOUND\"] = \"NOT_FOUND\";\n    return FallbackMode;\n}({});\n/**\n * Parses the fallback field from the prerender manifest.\n *\n * @param fallbackField The fallback field from the prerender manifest.\n * @returns The fallback mode.\n */ export function parseFallbackField(fallbackField) {\n    if (typeof fallbackField === 'string') {\n        return \"PRERENDER\";\n    } else if (fallbackField === null) {\n        return \"BLOCKING_STATIC_RENDER\";\n    } else if (fallbackField === false) {\n        return \"NOT_FOUND\";\n    } else if (fallbackField === undefined) {\n        return undefined;\n    } else {\n        throw Object.defineProperty(new Error(`Invalid fallback option: ${fallbackField}. Fallback option must be a string, null, undefined, or false.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E285\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nexport function fallbackModeToFallbackField(fallback, page) {\n    switch(fallback){\n        case \"BLOCKING_STATIC_RENDER\":\n            return null;\n        case \"NOT_FOUND\":\n            return false;\n        case \"PRERENDER\":\n            if (!page) {\n                throw Object.defineProperty(new Error(`Invariant: expected a page to be provided when fallback mode is \"${fallback}\"`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E422\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            return page;\n        default:\n            throw Object.defineProperty(new Error(`Invalid fallback mode: ${fallback}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E254\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n}\n/**\n * Parses the fallback from the static paths result.\n *\n * @param result The result from the static paths function.\n * @returns The fallback mode.\n */ export function parseStaticPathsResult(result) {\n    if (result === true) {\n        return \"PRERENDER\";\n    } else if (result === 'blocking') {\n        return \"BLOCKING_STATIC_RENDER\";\n    } else {\n        return \"NOT_FOUND\";\n    }\n}\n\n//# sourceMappingURL=fallback.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;AAAU,IAAI,eAAe,WAAW,GAAG,SAAS,YAAY;IAC7D;;;;GAID,GAAG,YAAY,CAAC,yBAAyB,GAAG;IAC3C;;;;GAID,GAAG,YAAY,CAAC,YAAY,GAAG;IAC9B;;;GAGD,GAAG,YAAY,CAAC,YAAY,GAAG;IAC9B,OAAO;AACX,EAAE,CAAC;AAMQ,SAAS,mBAAmB,aAAa;IAChD,IAAI,OAAO,kBAAkB,UAAU;QACnC,OAAO;IACX,OAAO,IAAI,kBAAkB,MAAM;QAC/B,OAAO;IACX,OAAO,IAAI,kBAAkB,OAAO;QAChC,OAAO;IACX,OAAO,IAAI,kBAAkB,WAAW;QACpC,OAAO;IACX,OAAO;QACH,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,yBAAyB,EAAE,cAAc,8DAA8D,CAAC,GAAG,qBAAqB;YACnK,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;AACJ;AACO,SAAS,4BAA4B,QAAQ,EAAE,IAAI;IACtD,OAAO;QACH,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,IAAI,CAAC,MAAM;gBACP,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,iEAAiE,EAAE,SAAS,CAAC,CAAC,GAAG,qBAAqB;oBACzI,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;YACJ;YACA,OAAO;QACX;YACI,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,uBAAuB,EAAE,UAAU,GAAG,qBAAqB;gBAC9F,OAAO;gBACP,YAAY;gBACZ,cAAc;YAClB;IACR;AACJ;AAMW,SAAS,uBAAuB,MAAM;IAC7C,IAAI,WAAW,MAAM;QACjB,OAAO;IACX,OAAO,IAAI,WAAW,YAAY;QAC9B,OAAO;IACX,OAAO;QACH,OAAO;IACX;AACJ,EAEA,oCAAoC","ignoreList":[0]}},
    {"offset": {"line": 2062, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/shared/lib/utils.js"],"sourcesContent":["/**\n * Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.\n * https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting\n */ export const WEB_VITALS = [\n    'CLS',\n    'FCP',\n    'FID',\n    'INP',\n    'LCP',\n    'TTFB'\n];\n/**\n * Utils\n */ export function execOnce(fn) {\n    let used = false;\n    let result;\n    return (...args)=>{\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nexport const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nexport function getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return `${protocol}//${hostname}${port ? ':' + port : ''}`;\n}\nexport function getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nexport function getDisplayName(Component) {\n    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\nexport function isResSent(res) {\n    return res.finished || res.headersSent;\n}\nexport function normalizeRepeatedSlashes(url) {\n    const urlParts = url.split('?');\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery// first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, '/').replace(/\\/\\/+/g, '/') + (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '');\n}\nexport async function loadGetInitialProps(App, ctx) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (App.prototype?.getInitialProps) {\n            const message = `\"${getDisplayName(App)}.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;\n            throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = `\"${getDisplayName(App)}.getInitialProps()\" should resolve to an object. But found \"${props}\" instead.`;\n        throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(`${getDisplayName(App)} returned an empty object from \\`getInitialProps\\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`);\n        }\n    }\n    return props;\n}\nexport const SP = typeof performance !== 'undefined';\nexport const ST = SP && [\n    'mark',\n    'measure',\n    'getEntriesByName'\n].every((method)=>typeof performance[method] === 'function');\nexport class DecodeError extends Error {\n}\nexport class NormalizeError extends Error {\n}\nexport class PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = 'ENOENT';\n        this.name = 'PageNotFoundError';\n        this.message = `Cannot find module for page: ${page}`;\n    }\n}\nexport class MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = `Failed to load static file for page: ${page} ${message}`;\n    }\n}\nexport class MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = 'ENOENT';\n        this.message = `Cannot find the middleware module`;\n    }\n}\nexport function stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n}\n\n//# sourceMappingURL=utils.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2228, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/lib/etag.js"],"sourcesContent":["/**\n * FNV-1a Hash implementation\n * @author Travis Webb (tjwebb) <me@traviswebb.com>\n *\n * Ported from https://github.com/tjwebb/fnv-plus/blob/master/index.js\n *\n * Simplified, optimized and add modified for 52 bit, which provides a larger hash space\n * and still making use of Javascript's 53-bit integer space.\n */ export const fnv1a52 = (str)=>{\n    const len = str.length;\n    let i = 0, t0 = 0, v0 = 0x2325, t1 = 0, v1 = 0x8422, t2 = 0, v2 = 0x9ce4, t3 = 0, v3 = 0xcbf2;\n    while(i < len){\n        v0 ^= str.charCodeAt(i++);\n        t0 = v0 * 435;\n        t1 = v1 * 435;\n        t2 = v2 * 435;\n        t3 = v3 * 435;\n        t2 += v0 << 8;\n        t3 += v1 << 8;\n        t1 += t0 >>> 16;\n        v0 = t0 & 65535;\n        t2 += t1 >>> 16;\n        v1 = t1 & 65535;\n        v3 = t3 + (t2 >>> 16) & 65535;\n        v2 = t2 & 65535;\n    }\n    return (v3 & 15) * 281474976710656 + v2 * 4294967296 + v1 * 65536 + (v0 ^ v3 >> 4);\n};\nexport const generateETag = (payload, weak = false)=>{\n    const prefix = weak ? 'W/\"' : '\"';\n    return prefix + fnv1a52(payload).toString(36) + payload.length.toString(36) + '\"';\n};\n\n//# sourceMappingURL=etag.js.map"],"names":[],"mappings":"AAAA;;;;;;;;CAQC;;;;;;AAAU,MAAM,UAAU,CAAC;IACxB,MAAM,MAAM,IAAI,MAAM;IACtB,IAAI,IAAI,GAAG,KAAK,GAAG,KAAK,QAAQ,KAAK,GAAG,KAAK,QAAQ,KAAK,GAAG,KAAK,QAAQ,KAAK,GAAG,KAAK;IACvF,MAAM,IAAI,IAAI;QACV,MAAM,IAAI,UAAU,CAAC;QACrB,KAAK,KAAK;QACV,KAAK,KAAK;QACV,KAAK,KAAK;QACV,KAAK,KAAK;QACV,MAAM,MAAM;QACZ,MAAM,MAAM;QACZ,MAAM,OAAO;QACb,KAAK,KAAK;QACV,MAAM,OAAO;QACb,KAAK,KAAK;QACV,KAAK,KAAK,CAAC,OAAO,EAAE,IAAI;QACxB,KAAK,KAAK;IACd;IACA,OAAO,CAAC,KAAK,EAAE,IAAI,kBAAkB,KAAK,aAAa,KAAK,QAAQ,CAAC,KAAK,MAAM,CAAC;AACrF;AACO,MAAM,eAAe,CAAC,SAAS,OAAO,KAAK;IAC9C,MAAM,SAAS,OAAO,QAAQ;IAC9B,OAAO,SAAS,QAAQ,SAAS,QAAQ,CAAC,MAAM,QAAQ,MAAM,CAAC,QAAQ,CAAC,MAAM;AAClF,GAEA,gCAAgC","ignoreList":[0]}},
    {"offset": {"line": 2269, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/compiled/fresh/index.js"],"sourcesContent":["(()=>{\"use strict\";var e={695:e=>{\n/*!\n * fresh\n * Copyright(c) 2012 TJ Holowaychuk\n * Copyright(c) 2016-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\nvar r=/(?:^|,)\\s*?no-cache\\s*?(?:,|$)/;e.exports=fresh;function fresh(e,a){var t=e[\"if-modified-since\"];var s=e[\"if-none-match\"];if(!t&&!s){return false}var i=e[\"cache-control\"];if(i&&r.test(i)){return false}if(s&&s!==\"*\"){var f=a[\"etag\"];if(!f){return false}var n=true;var u=parseTokenList(s);for(var _=0;_<u.length;_++){var o=u[_];if(o===f||o===\"W/\"+f||\"W/\"+o===f){n=false;break}}if(n){return false}}if(t){var p=a[\"last-modified\"];var v=!p||!(parseHttpDate(p)<=parseHttpDate(t));if(v){return false}}return true}function parseHttpDate(e){var r=e&&Date.parse(e);return typeof r===\"number\"?r:NaN}function parseTokenList(e){var r=0;var a=[];var t=0;for(var s=0,i=e.length;s<i;s++){switch(e.charCodeAt(s)){case 32:if(t===r){t=r=s+1}break;case 44:a.push(e.substring(t,r));t=r=s+1;break;default:r=s+1;break}}a.push(e.substring(t,r));return a}}};var r={};function __nccwpck_require__(a){var t=r[a];if(t!==undefined){return t.exports}var s=r[a]={exports:{}};var i=true;try{e[a](s,s.exports,__nccwpck_require__);i=false}finally{if(i)delete r[a]}return s.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var a=__nccwpck_require__(695);module.exports=a})();"],"names":[],"mappings":"AAAA,CAAC;IAAK;IAAa,IAAI,IAAE;QAAC,KAAI,CAAA;YAC9B;;;;;CAKC,GACD,IAAI,IAAE;YAAiC,EAAE,OAAO,GAAC;YAAM,SAAS,MAAM,CAAC,EAAC,CAAC;gBAAE,IAAI,IAAE,CAAC,CAAC,oBAAoB;gBAAC,IAAI,IAAE,CAAC,CAAC,gBAAgB;gBAAC,IAAG,CAAC,KAAG,CAAC,GAAE;oBAAC,OAAO;gBAAK;gBAAC,IAAI,IAAE,CAAC,CAAC,gBAAgB;gBAAC,IAAG,KAAG,EAAE,IAAI,CAAC,IAAG;oBAAC,OAAO;gBAAK;gBAAC,IAAG,KAAG,MAAI,KAAI;oBAAC,IAAI,IAAE,CAAC,CAAC,OAAO;oBAAC,IAAG,CAAC,GAAE;wBAAC,OAAO;oBAAK;oBAAC,IAAI,IAAE;oBAAK,IAAI,IAAE,eAAe;oBAAG,IAAI,IAAI,IAAE,GAAE,IAAE,EAAE,MAAM,EAAC,IAAI;wBAAC,IAAI,IAAE,CAAC,CAAC,EAAE;wBAAC,IAAG,MAAI,KAAG,MAAI,OAAK,KAAG,OAAK,MAAI,GAAE;4BAAC,IAAE;4BAAM;wBAAK;oBAAC;oBAAC,IAAG,GAAE;wBAAC,OAAO;oBAAK;gBAAC;gBAAC,IAAG,GAAE;oBAAC,IAAI,IAAE,CAAC,CAAC,gBAAgB;oBAAC,IAAI,IAAE,CAAC,KAAG,CAAC,CAAC,cAAc,MAAI,cAAc,EAAE;oBAAE,IAAG,GAAE;wBAAC,OAAO;oBAAK;gBAAC;gBAAC,OAAO;YAAI;YAAC,SAAS,cAAc,CAAC;gBAAE,IAAI,IAAE,KAAG,KAAK,KAAK,CAAC;gBAAG,OAAO,OAAO,MAAI,WAAS,IAAE;YAAG;YAAC,SAAS,eAAe,CAAC;gBAAE,IAAI,IAAE;gBAAE,IAAI,IAAE,EAAE;gBAAC,IAAI,IAAE;gBAAE,IAAI,IAAI,IAAE,GAAE,IAAE,EAAE,MAAM,EAAC,IAAE,GAAE,IAAI;oBAAC,OAAO,EAAE,UAAU,CAAC;wBAAI,KAAK;4BAAG,IAAG,MAAI,GAAE;gCAAC,IAAE,IAAE,IAAE;4BAAC;4BAAC;wBAAM,KAAK;4BAAG,EAAE,IAAI,CAAC,EAAE,SAAS,CAAC,GAAE;4BAAI,IAAE,IAAE,IAAE;4BAAE;wBAAM;4BAAQ,IAAE,IAAE;4BAAE;oBAAK;gBAAC;gBAAC,EAAE,IAAI,CAAC,EAAE,SAAS,CAAC,GAAE;gBAAI,OAAO;YAAC;QAAC;IAAC;IAAE,IAAI,IAAE,CAAC;IAAE,SAAS,oBAAoB,CAAC;QAAE,IAAI,IAAE,CAAC,CAAC,EAAE;QAAC,IAAG,MAAI,WAAU;YAAC,OAAO,EAAE,OAAO;QAAA;QAAC,IAAI,IAAE,CAAC,CAAC,EAAE,GAAC;YAAC,SAAQ,CAAC;QAAC;QAAE,IAAI,IAAE;QAAK,IAAG;YAAC,CAAC,CAAC,EAAE,CAAC,GAAE,EAAE,OAAO,EAAC;YAAqB,IAAE;QAAK,SAAQ;YAAC,IAAG,GAAE,OAAO,CAAC,CAAC,EAAE;QAAA;QAAC,OAAO,EAAE,OAAO;IAAA;IAAC,IAAG,OAAO,wBAAsB,aAAY,oBAAoB,EAAE,GAAC,8FAAU;IAAI,IAAI,IAAE,oBAAoB;IAAK,OAAO,OAAO,GAAC;AAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2372, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/lib/cache-control.js"],"sourcesContent":["import { CACHE_ONE_YEAR } from '../../lib/constants';\nexport function getCacheControlHeader({ revalidate, expire }) {\n    const swrHeader = typeof revalidate === 'number' && expire !== undefined && revalidate < expire ? `, stale-while-revalidate=${expire - revalidate}` : '';\n    if (revalidate === 0) {\n        return 'private, no-cache, no-store, max-age=0, must-revalidate';\n    } else if (typeof revalidate === 'number') {\n        return `s-maxage=${revalidate}${swrHeader}`;\n    }\n    return `s-maxage=${CACHE_ONE_YEAR}${swrHeader}`;\n}\n\n//# sourceMappingURL=cache-control.js.map"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,sBAAsB,EAAE,UAAU,EAAE,MAAM,EAAE;IACxD,MAAM,YAAY,OAAO,eAAe,YAAY,WAAW,aAAa,aAAa,SAAS,CAAC,yBAAyB,EAAE,SAAS,YAAY,GAAG;IACtJ,IAAI,eAAe,GAAG;QAClB,OAAO;IACX,OAAO,IAAI,OAAO,eAAe,UAAU;QACvC,OAAO,CAAC,SAAS,EAAE,aAAa,WAAW;IAC/C;IACA,OAAO,CAAC,SAAS,EAAE,2LAAc,GAAG,WAAW;AACnD,EAEA,yCAAyC","ignoreList":[0]}},
    {"offset": {"line": 2391, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/server/send-payload.js"],"sourcesContent":["import { isResSent } from '../shared/lib/utils';\nimport { generateETag } from './lib/etag';\nimport fresh from 'next/dist/compiled/fresh';\nimport { getCacheControlHeader } from './lib/cache-control';\nimport { HTML_CONTENT_TYPE_HEADER } from '../lib/constants';\nexport function sendEtagResponse(req, res, etag) {\n    if (etag) {\n        /**\n     * The server generating a 304 response MUST generate any of the\n     * following header fields that would have been sent in a 200 (OK)\n     * response to the same request: Cache-Control, Content-Location, Date,\n     * ETag, Expires, and Vary. https://tools.ietf.org/html/rfc7232#section-4.1\n     */ res.setHeader('ETag', etag);\n    }\n    if (fresh(req.headers, {\n        etag\n    })) {\n        res.statusCode = 304;\n        res.end();\n        return true;\n    }\n    return false;\n}\nexport async function sendRenderResult({ req, res, result, generateEtags, poweredByHeader, cacheControl }) {\n    if (isResSent(res)) {\n        return;\n    }\n    if (poweredByHeader && result.contentType === HTML_CONTENT_TYPE_HEADER) {\n        res.setHeader('X-Powered-By', 'Next.js');\n    }\n    // If cache control is already set on the response we don't\n    // override it to allow users to customize it via next.config\n    if (cacheControl && !res.getHeader('Cache-Control')) {\n        res.setHeader('Cache-Control', getCacheControlHeader(cacheControl));\n    }\n    const payload = result.isDynamic ? null : result.toUnchunkedString();\n    if (generateEtags && payload !== null) {\n        const etag = generateETag(payload);\n        if (sendEtagResponse(req, res, etag)) {\n            return;\n        }\n    }\n    if (!res.getHeader('Content-Type') && result.contentType) {\n        res.setHeader('Content-Type', result.contentType);\n    }\n    if (payload) {\n        res.setHeader('Content-Length', Buffer.byteLength(payload));\n    }\n    if (req.method === 'HEAD') {\n        res.end(null);\n        return;\n    }\n    if (payload !== null) {\n        res.end(payload);\n        return;\n    }\n    // Pipe the render result to the response after we get a writer for it.\n    await result.pipeToNodeResponse(res);\n}\n\n//# sourceMappingURL=send-payload.js.map"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AACO,SAAS,iBAAiB,GAAG,EAAE,GAAG,EAAE,IAAI;IAC3C,IAAI,MAAM;QACN;;;;;KAKH,GAAG,IAAI,SAAS,CAAC,QAAQ;IAC1B;IACA,IAAI,IAAA,uLAAK,EAAC,IAAI,OAAO,EAAE;QACnB;IACJ,IAAI;QACA,IAAI,UAAU,GAAG;QACjB,IAAI,GAAG;QACP,OAAO;IACX;IACA,OAAO;AACX;AACO,eAAe,iBAAiB,EAAE,GAAG,EAAE,GAAG,EAAE,MAAM,EAAE,aAAa,EAAE,eAAe,EAAE,YAAY,EAAE;IACrG,IAAI,IAAA,4LAAS,EAAC,MAAM;QAChB;IACJ;IACA,IAAI,mBAAmB,OAAO,WAAW,KAAK,qMAAwB,EAAE;QACpE,IAAI,SAAS,CAAC,gBAAgB;IAClC;IACA,2DAA2D;IAC3D,6DAA6D;IAC7D,IAAI,gBAAgB,CAAC,IAAI,SAAS,CAAC,kBAAkB;QACjD,IAAI,SAAS,CAAC,iBAAiB,IAAA,mNAAqB,EAAC;IACzD;IACA,MAAM,UAAU,OAAO,SAAS,GAAG,OAAO,OAAO,iBAAiB;IAClE,IAAI,iBAAiB,YAAY,MAAM;QACnC,MAAM,OAAO,IAAA,8LAAY,EAAC;QAC1B,IAAI,iBAAiB,KAAK,KAAK,OAAO;YAClC;QACJ;IACJ;IACA,IAAI,CAAC,IAAI,SAAS,CAAC,mBAAmB,OAAO,WAAW,EAAE;QACtD,IAAI,SAAS,CAAC,gBAAgB,OAAO,WAAW;IACpD;IACA,IAAI,SAAS;QACT,IAAI,SAAS,CAAC,kBAAkB,OAAO,UAAU,CAAC;IACtD;IACA,IAAI,IAAI,MAAM,KAAK,QAAQ;QACvB,IAAI,GAAG,CAAC;QACR;IACJ;IACA,IAAI,YAAY,MAAM;QAClB,IAAI,GAAG,CAAC;QACR;IACJ;IACA,uEAAuE;IACvE,MAAM,OAAO,kBAAkB,CAAC;AACpC,EAEA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 2464, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/compiled/bytes/index.js"],"sourcesContent":["(()=>{\"use strict\";var e={56:e=>{\n/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\ne.exports=bytes;e.exports.format=format;e.exports.parse=parse;var r=/\\B(?=(\\d{3})+(?!\\d))/g;var a=/(?:\\.0*|(\\.[^0]+)0+)$/;var t={b:1,kb:1<<10,mb:1<<20,gb:1<<30,tb:Math.pow(1024,4),pb:Math.pow(1024,5)};var i=/^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i;function bytes(e,r){if(typeof e===\"string\"){return parse(e)}if(typeof e===\"number\"){return format(e,r)}return null}function format(e,i){if(!Number.isFinite(e)){return null}var n=Math.abs(e);var o=i&&i.thousandsSeparator||\"\";var s=i&&i.unitSeparator||\"\";var f=i&&i.decimalPlaces!==undefined?i.decimalPlaces:2;var u=Boolean(i&&i.fixedDecimals);var p=i&&i.unit||\"\";if(!p||!t[p.toLowerCase()]){if(n>=t.pb){p=\"PB\"}else if(n>=t.tb){p=\"TB\"}else if(n>=t.gb){p=\"GB\"}else if(n>=t.mb){p=\"MB\"}else if(n>=t.kb){p=\"KB\"}else{p=\"B\"}}var b=e/t[p.toLowerCase()];var l=b.toFixed(f);if(!u){l=l.replace(a,\"$1\")}if(o){l=l.split(\".\").map((function(e,a){return a===0?e.replace(r,o):e})).join(\".\")}return l+s+p}function parse(e){if(typeof e===\"number\"&&!isNaN(e)){return e}if(typeof e!==\"string\"){return null}var r=i.exec(e);var a;var n=\"b\";if(!r){a=parseInt(e,10);n=\"b\"}else{a=parseFloat(r[1]);n=r[4].toLowerCase()}return Math.floor(t[n]*a)}}};var r={};function __nccwpck_require__(a){var t=r[a];if(t!==undefined){return t.exports}var i=r[a]={exports:{}};var n=true;try{e[a](i,i.exports,__nccwpck_require__);n=false}finally{if(n)delete r[a]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var a=__nccwpck_require__(56);module.exports=a})();"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2580, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/shared/lib/size-limit.js"],"sourcesContent":["export const DEFAULT_MAX_POSTPONED_STATE_SIZE = '100 MB';\nfunction parseSizeLimit(size) {\n    const bytes = require('next/dist/compiled/bytes').parse(size);\n    if (bytes === null || isNaN(bytes) || bytes < 1) {\n        return undefined;\n    }\n    return bytes;\n}\n/**\n * Parses the maxPostponedStateSize config value, using the default if not provided.\n */ export function parseMaxPostponedStateSize(size) {\n    return parseSizeLimit(size ?? DEFAULT_MAX_POSTPONED_STATE_SIZE);\n}\n\n//# sourceMappingURL=size-limit.js.map"],"names":[],"mappings":";;;;;;AAAO,MAAM,mCAAmC;AAChD,SAAS,eAAe,IAAI;IACxB,MAAM,QAAQ,uHAAoC,KAAK,CAAC;IACxD,IAAI,UAAU,QAAQ,MAAM,UAAU,QAAQ,GAAG;QAC7C,OAAO;IACX;IACA,OAAO;AACX;AAGW,SAAS,2BAA2B,IAAI;IAC/C,OAAO,eAAe,QAAQ;AAClC,EAEA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 2618, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/client/components/builtin/unauthorized.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return Unauthorized;\n    }\n});\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _errorfallback = require(\"../http-access-fallback/error-fallback\");\nfunction Unauthorized() {\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorfallback.HTTPAccessErrorFallback, {\n        status: 401,\n        message: \"You're not authorized to access this page.\"\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=unauthorized.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,WAAW;IACtC,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;AACN,SAAS;IACL,OAAO,WAAW,GAAG,CAAC,GAAG,YAAY,GAAG,EAAE,eAAe,uBAAuB,EAAE;QAC9E,QAAQ;QACR,SAAS;IACb;AACJ;AAEA,IAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,cAAe,OAAO,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,KAAK,IAAK,KAAK,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,aAAa;IACrK,OAAO,cAAc,CAAC,QAAQ,OAAO,EAAE,cAAc;QAAE,OAAO;IAAK;IACnE,OAAO,MAAM,CAAC,QAAQ,OAAO,EAAE;IAC/B,OAAO,OAAO,GAAG,QAAQ,OAAO;AAClC,EAEA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 2650, "column": 0}, "map": {"version":3,"sources":["file:///Users/ap24/uwo-chatbot/node_modules/next/dist/esm/build/templates/app-page.js%3Fpage%3D/_not-found/page"],"sourcesContent":["const __TURBOPACK__layout__$23$0__ = () => require(\"MODULE_0\");\n\nconst __TURBOPACK__not$2d$found__$23$1__ = () => require(\"MODULE_1\");\n\nconst __TURBOPACK__forbidden__$23$2__ = () => require(\"MODULE_2\");\n\nconst __TURBOPACK__unauthorized__$23$3__ = () => require(\"MODULE_3\");\n\nconst __TURBOPACK__page__$23$4__ = () => require(\"MODULE_4\");\n\nimport { AppPageRouteModule } from \"next/dist/esm/server/route-modules/app-page/module.compiled\" with {\n    'turbopack-transition': 'next-ssr'\n};\nimport { RouteKind } from \"next/dist/esm/server/route-kind\" with {\n    'turbopack-transition': 'next-server-utility'\n};\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { interopDefault } from \"next/dist/esm/server/app-render/interop-default\";\nimport { stripFlightHeaders } from \"next/dist/esm/server/app-render/strip-flight-headers\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { checkIsAppPPREnabled } from \"next/dist/esm/server/lib/experimental/ppr\";\nimport { getFallbackRouteParams, createOpaqueFallbackRouteParams } from \"next/dist/esm/server/request/fallback-params\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { isHtmlBotRequest, shouldServeStreamingMetadata } from \"next/dist/esm/server/lib/streaming-metadata\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { getIsPossibleServerAction } from \"next/dist/esm/server/lib/server-action-request-meta\";\nimport { RSC_HEADER, NEXT_ROUTER_PREFETCH_HEADER, NEXT_IS_PRERENDER_HEADER, NEXT_DID_POSTPONE_HEADER, RSC_CONTENT_TYPE_HEADER } from \"next/dist/esm/client/components/app-router-headers\";\nimport { getBotType, isBot } from \"next/dist/esm/shared/lib/router/utils/is-bot\";\nimport { CachedRouteKind, IncrementalCacheKind } from \"next/dist/esm/server/response-cache\";\nimport { FallbackMode, parseFallbackField } from \"next/dist/esm/lib/fallback\";\nimport RenderResult from \"next/dist/esm/server/render-result\";\nimport { CACHE_ONE_YEAR, HTML_CONTENT_TYPE_HEADER, NEXT_CACHE_TAGS_HEADER, NEXT_RESUME_HEADER } from \"next/dist/esm/lib/constants\";\nimport { ENCODED_TAGS } from \"next/dist/esm/server/stream-utils/encoded-tags\";\nimport { sendRenderResult } from \"next/dist/esm/server/send-payload\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { parseMaxPostponedStateSize } from \"next/dist/esm/shared/lib/size-limit\";\n// We inject the tree and pages here so that we can use them in the route\n// module.\nconst tree = [\"\", {\n\"children\": [\"/_not-found\", {\n\"children\": [\"__PAGE__\", {\n}, {\n  metadata: {  },  \"page\": [__TURBOPACK__page__$23$4__, \"[project]/uwo-chatbot/node_modules/next/dist/client/components/builtin/not-found.js\"],\n}],\n}, {\n  metadata: {  },}],\n}, {\n  \"layout\": [__TURBOPACK__layout__$23$0__, \"[project]/uwo-chatbot/app/layout.tsx\"],\n  \"not-found\": [__TURBOPACK__not$2d$found__$23$1__, \"[project]/uwo-chatbot/node_modules/next/dist/client/components/builtin/not-found.js\"],\n  \"forbidden\": [__TURBOPACK__forbidden__$23$2__, \"[project]/uwo-chatbot/node_modules/next/dist/client/components/builtin/forbidden.js\"],\n  \"unauthorized\": [__TURBOPACK__unauthorized__$23$3__, \"[project]/uwo-chatbot/node_modules/next/dist/client/components/builtin/unauthorized.js\"],\n}]\nimport GlobalError from \"next/dist/client/components/builtin/global-error\" with {\n    'turbopack-transition': 'next-server-utility'\n};\nexport { GlobalError };\nconst __next_app_require__ = __turbopack_context__.r.bind(__turbopack_context__)\nconst __next_app_load_chunk__ = __turbopack_context__.l.bind(__turbopack_context__)\nexport const __next_app__ = {\n    require: __next_app_require__,\n    loadChunk: __next_app_load_chunk__\n};\nimport * as entryBase from \"next/dist/esm/server/app-render/entry-base\" with {\n    'turbopack-transition': 'next-server-utility'\n};\nimport { RedirectStatusCode } from \"next/dist/esm/client/components/redirect-status-code\";\nimport { InvariantError } from \"next/dist/esm/shared/lib/invariant-error\";\nimport { scheduleOnNextTick } from \"next/dist/esm/lib/scheduler\";\nimport { isInterceptionRouteAppPath } from \"next/dist/esm/shared/lib/router/utils/interception-routes\";\nexport * from \"next/dist/esm/server/app-render/entry-base\" with {\n    'turbopack-transition': 'next-server-utility'\n};\n// Create and export the route module that will be consumed.\nexport const routeModule = new AppPageRouteModule({\n    definition: {\n        kind: RouteKind.APP_PAGE,\n        page: \"/_not-found/page\",\n        pathname: \"/_not-found\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: '',\n        appPaths: []\n    },\n    userland: {\n        loaderTree: tree\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || ''\n});\nexport async function handler(req, res, ctx) {\n    var _this;\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n    let srcPage = \"/_not-found/page\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, query, params, pageIsDynamic, buildManifest, nextFontManifest, reactLoadableManifest, serverActionsManifest, clientReferenceManifest, subresourceIntegrityManifest, prerenderManifest, isDraftMode, resolvedPathname, revalidateOnlyGenerated, routerServerContext, nextConfig, parsedUrl, interceptionRoutePatterns, deploymentId } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let { isOnDemandRevalidate } = prepareResult;\n    // We use the resolvedPathname instead of the parsedUrl.pathname because it\n    // is not rewritten as resolvedPathname is. This will ensure that the correct\n    // prerender info is used instead of using the original pathname as the\n    // source. If however PPR is enabled and cacheComponents is disabled, we\n    // treat the pathname as dynamic. Currently, there's a bug in the PPR\n    // implementation that incorrectly leaves %%drp placeholders in the output of\n    // parallel routes. This is addressed with cacheComponents.\n    const prerenderInfo = nextConfig.experimental.ppr && !nextConfig.cacheComponents && isInterceptionRouteAppPath(resolvedPathname) ? null : routeModule.match(resolvedPathname, prerenderManifest);\n    const isPrerendered = !!prerenderManifest.routes[resolvedPathname];\n    const userAgent = req.headers['user-agent'] || '';\n    const botType = getBotType(userAgent);\n    const isHtmlBot = isHtmlBotRequest(req);\n    /**\n   * If true, this indicates that the request being made is for an app\n   * prefetch request.\n   */ const isPrefetchRSCRequest = getRequestMeta(req, 'isPrefetchRSCRequest') ?? req.headers[NEXT_ROUTER_PREFETCH_HEADER] === '1' // exclude runtime prefetches, which use '2'\n    ;\n    // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n    const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? Boolean(req.headers[RSC_HEADER]);\n    const isPossibleServerAction = getIsPossibleServerAction(req);\n    /**\n   * If the route being rendered is an app page, and the ppr feature has been\n   * enabled, then the given route _could_ support PPR.\n   */ const couldSupportPPR = checkIsAppPPREnabled(nextConfig.experimental.ppr);\n    if (!getRequestMeta(req, 'postponed') && couldSupportPPR && req.headers[NEXT_RESUME_HEADER] === '1' && req.method === 'POST') {\n        // Decode the postponed state from the request body, it will come as\n        // an array of buffers, so collect them and then concat them to form\n        // the string.\n        const body = [];\n        for await (const chunk of req){\n            body.push(chunk);\n        }\n        const postponed = Buffer.concat(body).toString('utf8');\n        addRequestMeta(req, 'postponed', postponed);\n    }\n    // When enabled, this will allow the use of the `?__nextppronly` query to\n    // enable debugging of the static shell.\n    const hasDebugStaticShellQuery = process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' && typeof query.__nextppronly !== 'undefined' && couldSupportPPR;\n    // When enabled, this will allow the use of the `?__nextppronly` query\n    // to enable debugging of the fallback shell.\n    const hasDebugFallbackShellQuery = hasDebugStaticShellQuery && query.__nextppronly === 'fallback';\n    // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n    // prerender manifest and this is an app page.\n    const isRoutePPREnabled = couldSupportPPR && (((_this = prerenderManifest.routes[normalizedSrcPage] ?? prerenderManifest.dynamicRoutes[normalizedSrcPage]) == null ? void 0 : _this.renderingMode) === 'PARTIALLY_STATIC' || // Ideally we'd want to check the appConfig to see if this page has PPR\n    // enabled or not, but that would require plumbing the appConfig through\n    // to the server during development. We assume that the page supports it\n    // but only during development.\n    hasDebugStaticShellQuery && (routeModule.isDev === true || (routerServerContext == null ? void 0 : routerServerContext.experimentalTestProxy) === true));\n    const isDebugStaticShell = hasDebugStaticShellQuery && isRoutePPREnabled;\n    // We should enable debugging dynamic accesses when the static shell\n    // debugging has been enabled and we're also in development mode.\n    const isDebugDynamicAccesses = isDebugStaticShell && routeModule.isDev === true;\n    const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled;\n    // If we're in minimal mode, then try to get the postponed information from\n    // the request metadata. If available, use it for resuming the postponed\n    // render.\n    const minimalPostponed = isRoutePPREnabled ? getRequestMeta(req, 'postponed') : undefined;\n    // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n    // we can use this fact to only generate the flight data for the request\n    // because we can't cache the HTML (as it's also dynamic).\n    let isDynamicRSCRequest = isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest;\n    // During a PPR revalidation, the RSC request is not dynamic if we do not have the postponed data.\n    // We only attach the postponed data during a resume. If there's no postponed data, then it must be a revalidation.\n    // This is to ensure that we don't bypass the cache during a revalidation.\n    if (isMinimalMode) {\n        isDynamicRSCRequest = isDynamicRSCRequest && !!minimalPostponed;\n    }\n    // Need to read this before it's stripped by stripFlightHeaders. We don't\n    // need to transfer it to the request meta because it's only read\n    // within this function; the static segment data should have already been\n    // generated, so we will always either return a static response or a 404.\n    const segmentPrefetchHeader = getRequestMeta(req, 'segmentPrefetchRSCRequest');\n    // TODO: investigate existing bug with shouldServeStreamingMetadata always\n    // being true for a revalidate due to modifying the base-server this.renderOpts\n    // when fixing this to correct logic it causes hydration issue since we set\n    // serveStreamingMetadata to true during export\n    const serveStreamingMetadata = isHtmlBot && isRoutePPREnabled ? false : !userAgent ? true : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots);\n    const isSSG = Boolean((prerenderInfo || isPrerendered || prerenderManifest.routes[normalizedSrcPage]) && // If this is a html bot request and PPR is enabled, then we don't want\n    // to serve a static response.\n    !(isHtmlBot && isRoutePPREnabled));\n    // When a page supports cacheComponents, we can support RDC for Navigations\n    const supportsRDCForNavigations = isRoutePPREnabled && nextConfig.cacheComponents === true;\n    // In development, we always want to generate dynamic HTML.\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML, unless it's\n    // a data request, in which case we only produce static HTML.\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isSSG || // If this request has provided postponed data, it supports dynamic\n    // HTML.\n    typeof minimalPostponed === 'string' || // If this handler supports onCacheEntryV2, then we can only support\n    // dynamic responses if it's a dynamic RSC request and not in minimal mode. If it\n    // doesn't support it we must fallback to the default behavior.\n    (supportsRDCForNavigations && getRequestMeta(req, 'onCacheEntryV2') ? // which will generate the RDC for the route. When resuming a Dynamic\n    // RSC request, we'll pass the minimal postponed data to the render\n    // which will trigger the `supportsDynamicResponse` to be true.\n    isDynamicRSCRequest && !isMinimalMode : isDynamicRSCRequest);\n    // When html bots request PPR page, perform the full dynamic rendering.\n    const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled;\n    let ssgCacheKey = null;\n    if (!isDraftMode && isSSG && !supportsDynamicResponse && !isPossibleServerAction && !minimalPostponed && !isDynamicRSCRequest) {\n        ssgCacheKey = resolvedPathname;\n    }\n    // the staticPathKey differs from ssgCacheKey since\n    // ssgCacheKey is null in dev since we're always in \"dynamic\"\n    // mode in dev to bypass the cache, but we still need to honor\n    // dynamicParams = false in dev mode\n    let staticPathKey = ssgCacheKey;\n    if (!staticPathKey && routeModule.isDev) {\n        staticPathKey = resolvedPathname;\n    }\n    // If this is a request for an app path that should be statically generated\n    // and we aren't in the edge runtime, strip the flight headers so it will\n    // generate the static response.\n    if (!routeModule.isDev && !isDraftMode && isSSG && isRSCRequest && !isDynamicRSCRequest) {\n        stripFlightHeaders(req.headers);\n    }\n    const ComponentMod = {\n        ...entryBase,\n        tree,\n        GlobalError,\n        handler,\n        routeModule,\n        __next_app__\n    };\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    try {\n        const varyHeader = routeModule.getVaryHeader(resolvedPathname, interceptionRoutePatterns);\n        res.setHeader('Vary', varyHeader);\n        const invokeRouteModule = async (span, context)=>{\n            const nextReq = new NodeNextRequest(req);\n            const nextRes = new NodeNextResponse(res);\n            return routeModule.render(nextReq, nextRes, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const incrementalCache = getRequestMeta(req, 'incrementalCache');\n        const doRender = async ({ span, postponed, fallbackRouteParams, forceStaticRender })=>{\n            const context = {\n                query,\n                params,\n                page: normalizedSrcPage,\n                sharedContext: {\n                    buildId\n                },\n                serverComponentsHmrCache: getRequestMeta(req, 'serverComponentsHmrCache'),\n                fallbackRouteParams,\n                renderOpts: {\n                    App: ()=>null,\n                    Document: ()=>null,\n                    pageConfig: {},\n                    ComponentMod,\n                    Component: interopDefault(ComponentMod),\n                    params,\n                    routeModule,\n                    page: srcPage,\n                    postponed,\n                    shouldWaitOnAllReady,\n                    serveStreamingMetadata,\n                    supportsDynamicResponse: typeof postponed === 'string' || supportsDynamicResponse,\n                    buildManifest,\n                    nextFontManifest,\n                    reactLoadableManifest,\n                    subresourceIntegrityManifest,\n                    setCacheStatus: routerServerContext == null ? void 0 : routerServerContext.setCacheStatus,\n                    setIsrStatus: routerServerContext == null ? void 0 : routerServerContext.setIsrStatus,\n                    setReactDebugChannel: routerServerContext == null ? void 0 : routerServerContext.setReactDebugChannel,\n                    sendErrorsToBrowser: routerServerContext == null ? void 0 : routerServerContext.sendErrorsToBrowser,\n                    dir: process.env.NEXT_RUNTIME === 'nodejs' ? require('path').join(/* turbopackIgnore: true */ process.cwd(), routeModule.relativeProjectDir) : `${process.cwd()}/${routeModule.relativeProjectDir}`,\n                    isDraftMode,\n                    botType,\n                    isOnDemandRevalidate,\n                    isPossibleServerAction,\n                    assetPrefix: nextConfig.assetPrefix,\n                    nextConfigOutput: nextConfig.output,\n                    crossOrigin: nextConfig.crossOrigin,\n                    trailingSlash: nextConfig.trailingSlash,\n                    images: nextConfig.images,\n                    previewProps: prerenderManifest.preview,\n                    deploymentId: deploymentId,\n                    enableTainting: nextConfig.experimental.taint,\n                    htmlLimitedBots: nextConfig.htmlLimitedBots,\n                    reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n                    multiZoneDraftMode,\n                    incrementalCache,\n                    cacheLifeProfiles: nextConfig.cacheLife,\n                    basePath: nextConfig.basePath,\n                    serverActions: nextConfig.experimental.serverActions,\n                    ...isDebugStaticShell || isDebugDynamicAccesses || isDebugFallbackShell ? {\n                        nextExport: true,\n                        supportsDynamicResponse: false,\n                        isStaticGeneration: true,\n                        isDebugDynamicAccesses: isDebugDynamicAccesses\n                    } : {},\n                    cacheComponents: Boolean(nextConfig.cacheComponents),\n                    experimental: {\n                        isRoutePPREnabled,\n                        expireTime: nextConfig.expireTime,\n                        staleTimes: nextConfig.experimental.staleTimes,\n                        dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),\n                        inlineCss: Boolean(nextConfig.experimental.inlineCss),\n                        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n                        clientTraceMetadata: nextConfig.experimental.clientTraceMetadata || [],\n                        clientParamParsingOrigins: nextConfig.experimental.clientParamParsingOrigins,\n                        maxPostponedStateSizeBytes: parseMaxPostponedStateSize(nextConfig.experimental.maxPostponedStateSize)\n                    },\n                    waitUntil: ctx.waitUntil,\n                    onClose: (cb)=>{\n                        res.on('close', cb);\n                    },\n                    onAfterTaskError: ()=>{},\n                    onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext),\n                    err: getRequestMeta(req, 'invokeError'),\n                    dev: routeModule.isDev\n                }\n            };\n            if (isDebugStaticShell || isDebugDynamicAccesses) {\n                context.renderOpts.nextExport = true;\n                context.renderOpts.supportsDynamicResponse = false;\n                context.renderOpts.isDebugDynamicAccesses = isDebugDynamicAccesses;\n            }\n            // When we're revalidating in the background, we should not allow dynamic\n            // responses.\n            if (forceStaticRender) {\n                context.renderOpts.supportsDynamicResponse = false;\n            }\n            const result = await invokeRouteModule(span, context);\n            const { metadata } = result;\n            const { cacheControl, headers = {}, // Add any fetch tags that were on the page to the response headers.\n            fetchTags: cacheTags, fetchMetrics } = metadata;\n            if (cacheTags) {\n                headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n            }\n            // Pull any fetch metrics from the render onto the request.\n            ;\n            req.fetchMetrics = fetchMetrics;\n            // we don't throw static to dynamic errors in dev as isSSG\n            // is a best guess in dev since we don't have the prerender pass\n            // to know whether the path is actually static or not\n            if (isSSG && (cacheControl == null ? void 0 : cacheControl.revalidate) === 0 && !routeModule.isDev && !isRoutePPREnabled) {\n                const staticBailoutInfo = metadata.staticBailoutInfo;\n                const err = Object.defineProperty(new Error(`Page changed from static to dynamic at runtime ${resolvedPathname}${(staticBailoutInfo == null ? void 0 : staticBailoutInfo.description) ? `, reason: ${staticBailoutInfo.description}` : ``}` + `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E132\",\n                    enumerable: false,\n                    configurable: true\n                });\n                if (staticBailoutInfo == null ? void 0 : staticBailoutInfo.stack) {\n                    const stack = staticBailoutInfo.stack;\n                    err.stack = err.message + stack.substring(stack.indexOf('\\n'));\n                }\n                throw err;\n            }\n            return {\n                value: {\n                    kind: CachedRouteKind.APP_PAGE,\n                    html: result,\n                    headers,\n                    rscData: metadata.flightData,\n                    postponed: metadata.postponed,\n                    status: metadata.statusCode,\n                    segmentData: metadata.segmentData\n                },\n                cacheControl\n            };\n        };\n        const responseGenerator = async ({ hasResolved, previousCacheEntry: previousIncrementalCacheEntry, isRevalidating, span, forceStaticRender = false })=>{\n            const isProduction = routeModule.isDev === false;\n            const didRespond = hasResolved || res.writableEnded;\n            // skip on-demand revalidate if cache is not present and\n            // revalidate-if-generated is set\n            if (isOnDemandRevalidate && revalidateOnlyGenerated && !previousIncrementalCacheEntry && !isMinimalMode) {\n                if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n                    await routerServerContext.render404(req, res);\n                } else {\n                    res.statusCode = 404;\n                    res.end('This page could not be found');\n                }\n                return null;\n            }\n            let fallbackMode;\n            if (prerenderInfo) {\n                fallbackMode = parseFallbackField(prerenderInfo.fallback);\n            }\n            // When serving a HTML bot request, we want to serve a blocking render and\n            // not the prerendered page. This ensures that the correct content is served\n            // to the bot in the head.\n            if (fallbackMode === FallbackMode.PRERENDER && isBot(userAgent)) {\n                if (!isRoutePPREnabled || isHtmlBot) {\n                    fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER;\n                }\n            }\n            if ((previousIncrementalCacheEntry == null ? void 0 : previousIncrementalCacheEntry.isStale) === -1) {\n                isOnDemandRevalidate = true;\n            }\n            // TODO: adapt for PPR\n            // only allow on-demand revalidate for fallback: true/blocking\n            // or for prerendered fallback: false paths\n            if (isOnDemandRevalidate && (fallbackMode !== FallbackMode.NOT_FOUND || previousIncrementalCacheEntry)) {\n                fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER;\n            }\n            if (!isMinimalMode && fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER && staticPathKey && !didRespond && !isDraftMode && pageIsDynamic && (isProduction || !isPrerendered)) {\n                // if the page has dynamicParams: false and this pathname wasn't\n                // prerendered trigger the no fallback handling\n                if (// In development, fall through to render to handle missing\n                // getStaticPaths.\n                (isProduction || prerenderInfo) && // When fallback isn't present, abort this render so we 404\n                fallbackMode === FallbackMode.NOT_FOUND) {\n                    if (nextConfig.experimental.adapterPath) {\n                        return await render404();\n                    }\n                    throw new NoFallbackError();\n                }\n                // When cacheComponents is enabled, we can use the fallback\n                // response if the request is not a dynamic RSC request because the\n                // RSC data when this feature flag is enabled does not contain any\n                // param references. Without this feature flag enabled, the RSC data\n                // contains param references, and therefore we can't use the fallback.\n                if (isRoutePPREnabled && (nextConfig.cacheComponents ? !isDynamicRSCRequest : !isRSCRequest)) {\n                    const cacheKey = isProduction && typeof (prerenderInfo == null ? void 0 : prerenderInfo.fallback) === 'string' ? prerenderInfo.fallback : normalizedSrcPage;\n                    const fallbackRouteParams = // If we're in production and we have fallback route params, then we\n                    // can use the manifest fallback route params.\n                    isProduction && (prerenderInfo == null ? void 0 : prerenderInfo.fallbackRouteParams) ? createOpaqueFallbackRouteParams(prerenderInfo.fallbackRouteParams) : // have to manually generate the fallback route params.\n                    isDebugFallbackShell ? getFallbackRouteParams(normalizedSrcPage, routeModule) : null;\n                    // We use the response cache here to handle the revalidation and\n                    // management of the fallback shell.\n                    const fallbackResponse = await routeModule.handleResponse({\n                        cacheKey,\n                        req,\n                        nextConfig,\n                        routeKind: RouteKind.APP_PAGE,\n                        isFallback: true,\n                        prerenderManifest,\n                        isRoutePPREnabled,\n                        responseGenerator: async ()=>doRender({\n                                span,\n                                // We pass `undefined` as rendering a fallback isn't resumed\n                                // here.\n                                postponed: undefined,\n                                fallbackRouteParams,\n                                forceStaticRender: false\n                            }),\n                        waitUntil: ctx.waitUntil,\n                        isMinimalMode\n                    });\n                    // If the fallback response was set to null, then we should return null.\n                    if (fallbackResponse === null) return null;\n                    // Otherwise, if we did get a fallback response, we should return it.\n                    if (fallbackResponse) {\n                        // Remove the cache control from the response to prevent it from being\n                        // used in the surrounding cache.\n                        delete fallbackResponse.cacheControl;\n                        return fallbackResponse;\n                    }\n                }\n            }\n            // Only requests that aren't revalidating can be resumed. If we have the\n            // minimal postponed data, then we should resume the render with it.\n            let postponed = !isOnDemandRevalidate && !isRevalidating && minimalPostponed ? minimalPostponed : undefined;\n            // If this is a dynamic RSC request, we should use the postponed data from\n            // the static render (if available). This ensures that we can utilize the\n            // resume data cache (RDC) from the static render to ensure that the data\n            // is consistent between the static and dynamic renders.\n            if (// Only enable RDC for Navigations if the feature is enabled.\n            supportsRDCForNavigations && process.env.NEXT_RUNTIME !== 'edge' && !isMinimalMode && incrementalCache && isDynamicRSCRequest && // We don't typically trigger an on-demand revalidation for dynamic RSC\n            // requests, as we're typically revalidating the page in the background\n            // instead. However, if the cache entry is stale, we should trigger a\n            // background revalidation on dynamic RSC requests. This prevents us\n            // from entering an infinite loop of revalidations.\n            !forceStaticRender) {\n                const incrementalCacheEntry = await incrementalCache.get(resolvedPathname, {\n                    kind: IncrementalCacheKind.APP_PAGE,\n                    isRoutePPREnabled: true,\n                    isFallback: false\n                });\n                // If the cache entry is found, we should use the postponed data from\n                // the cache.\n                if (incrementalCacheEntry && incrementalCacheEntry.value && incrementalCacheEntry.value.kind === CachedRouteKind.APP_PAGE) {\n                    // CRITICAL: we're assigning the postponed data from the cache entry\n                    // here as we're using the RDC to resume the render.\n                    postponed = incrementalCacheEntry.value.postponed;\n                    // If the cache entry is stale, we should trigger a background\n                    // revalidation so that subsequent requests will get a fresh response.\n                    if (incrementalCacheEntry && // We want to trigger this flow if the cache entry is stale and if\n                    // the requested revalidation flow is either foreground or\n                    // background.\n                    (incrementalCacheEntry.isStale === -1 || incrementalCacheEntry.isStale === true)) {\n                        // We want to schedule this on the next tick to ensure that the\n                        // render is not blocked on it.\n                        scheduleOnNextTick(async ()=>{\n                            const responseCache = routeModule.getResponseCache(req);\n                            try {\n                                await responseCache.revalidate(resolvedPathname, incrementalCache, isRoutePPREnabled, false, (c)=>responseGenerator({\n                                        ...c,\n                                        // CRITICAL: we need to set this to true as we're\n                                        // revalidating in the background and typically this dynamic\n                                        // RSC request is not treated as static.\n                                        forceStaticRender: true\n                                    }), // CRITICAL: we need to pass null here because passing the\n                                // previous cache entry here (which is stale) will switch on\n                                // isOnDemandRevalidate and break the prerendering.\n                                null, hasResolved, ctx.waitUntil);\n                            } catch (err) {\n                                console.error('Error revalidating the page in the background', err);\n                            }\n                        });\n                    }\n                }\n            }\n            // When we're in minimal mode, if we're trying to debug the static shell,\n            // we should just return nothing instead of resuming the dynamic render.\n            if ((isDebugStaticShell || isDebugDynamicAccesses) && typeof postponed !== 'undefined') {\n                return {\n                    cacheControl: {\n                        revalidate: 1,\n                        expire: undefined\n                    },\n                    value: {\n                        kind: CachedRouteKind.PAGES,\n                        html: RenderResult.EMPTY,\n                        pageData: {},\n                        headers: undefined,\n                        status: undefined\n                    }\n                };\n            }\n            const fallbackRouteParams = // If we're in production and we have fallback route params, then we\n            // can use the manifest fallback route params if we need to render the\n            // fallback shell.\n            isProduction && (prerenderInfo == null ? void 0 : prerenderInfo.fallbackRouteParams) && getRequestMeta(req, 'renderFallbackShell') ? createOpaqueFallbackRouteParams(prerenderInfo.fallbackRouteParams) : // manually generate the fallback route params.\n            isDebugFallbackShell ? getFallbackRouteParams(normalizedSrcPage, routeModule) : null;\n            // Perform the render.\n            return doRender({\n                span,\n                postponed,\n                fallbackRouteParams,\n                forceStaticRender\n            });\n        };\n        const handleResponse = async (span)=>{\n            var _cacheEntry_value, _cachedData_headers;\n            const cacheEntry = await routeModule.handleResponse({\n                cacheKey: ssgCacheKey,\n                responseGenerator: (c)=>responseGenerator({\n                        span,\n                        ...c\n                    }),\n                routeKind: RouteKind.APP_PAGE,\n                isOnDemandRevalidate,\n                isRoutePPREnabled,\n                req,\n                nextConfig,\n                prerenderManifest,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            // In dev, we should not cache pages for any reason.\n            if (routeModule.isDev) {\n                res.setHeader('Cache-Control', 'no-store, must-revalidate');\n            }\n            if (!cacheEntry) {\n                if (ssgCacheKey) {\n                    // A cache entry might not be generated if a response is written\n                    // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n                    // have a cache key. If we do have a cache key but we don't end up\n                    // with a cache entry, then either Next.js or the application has a\n                    // bug that needs fixing.\n                    throw Object.defineProperty(new Error('invariant: cache entry required but not generated'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E62\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                return null;\n            }\n            if (((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_PAGE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant app-page handler received invalid cache entry ${(_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E707\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            const didPostpone = typeof cacheEntry.value.postponed === 'string';\n            if (isSSG && // We don't want to send a cache header for requests that contain dynamic\n            // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n            // request, then we should set the cache header.\n            !isDynamicRSCRequest && (!didPostpone || isPrefetchRSCRequest)) {\n                if (!isMinimalMode) {\n                    // set x-nextjs-cache header to match the header\n                    // we set for the image-optimizer\n                    res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n                }\n                // Set a header used by the client router to signal the response is static\n                // and should respect the `static` cache staleTime value.\n                res.setHeader(NEXT_IS_PRERENDER_HEADER, '1');\n            }\n            const { value: cachedData } = cacheEntry;\n            // Coerce the cache control parameter from the render.\n            let cacheControl;\n            // If this is a resume request in minimal mode it is streamed with dynamic\n            // content and should not be cached.\n            if (minimalPostponed) {\n                cacheControl = {\n                    revalidate: 0,\n                    expire: undefined\n                };\n            } else if (isDynamicRSCRequest) {\n                cacheControl = {\n                    revalidate: 0,\n                    expire: undefined\n                };\n            } else if (!routeModule.isDev) {\n                // If this is a preview mode request, we shouldn't cache it\n                if (isDraftMode) {\n                    cacheControl = {\n                        revalidate: 0,\n                        expire: undefined\n                    };\n                } else if (!isSSG) {\n                    if (!res.getHeader('Cache-Control')) {\n                        cacheControl = {\n                            revalidate: 0,\n                            expire: undefined\n                        };\n                    }\n                } else if (cacheEntry.cacheControl) {\n                    // If the cache entry has a cache control with a revalidate value that's\n                    // a number, use it.\n                    if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n                        var _cacheEntry_cacheControl;\n                        if (cacheEntry.cacheControl.revalidate < 1) {\n                            throw Object.defineProperty(new Error(`Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E22\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        cacheControl = {\n                            revalidate: cacheEntry.cacheControl.revalidate,\n                            expire: ((_cacheEntry_cacheControl = cacheEntry.cacheControl) == null ? void 0 : _cacheEntry_cacheControl.expire) ?? nextConfig.expireTime\n                        };\n                    } else {\n                        cacheControl = {\n                            revalidate: CACHE_ONE_YEAR,\n                            expire: undefined\n                        };\n                    }\n                }\n            }\n            cacheEntry.cacheControl = cacheControl;\n            if (typeof segmentPrefetchHeader === 'string' && (cachedData == null ? void 0 : cachedData.kind) === CachedRouteKind.APP_PAGE && cachedData.segmentData) {\n                var _cachedData_headers1;\n                // This is a prefetch request issued by the client Segment Cache. These\n                // should never reach the application layer (lambda). We should either\n                // respond from the cache (HIT) or respond with 204 No Content (MISS).\n                // Set a header to indicate that PPR is enabled for this route. This\n                // lets the client distinguish between a regular cache miss and a cache\n                // miss due to PPR being disabled. In other contexts this header is used\n                // to indicate that the response contains dynamic data, but here we're\n                // only using it to indicate that the feature is enabled  the segment\n                // response itself contains whether the data is dynamic.\n                res.setHeader(NEXT_DID_POSTPONE_HEADER, '2');\n                // Add the cache tags header to the response if it exists and we're in\n                // minimal mode while rendering a static page.\n                const tags = (_cachedData_headers1 = cachedData.headers) == null ? void 0 : _cachedData_headers1[NEXT_CACHE_TAGS_HEADER];\n                if (isMinimalMode && isSSG && tags && typeof tags === 'string') {\n                    res.setHeader(NEXT_CACHE_TAGS_HEADER, tags);\n                }\n                const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader);\n                if (matchedSegment !== undefined) {\n                    // Cache hit\n                    return sendRenderResult({\n                        req,\n                        res,\n                        generateEtags: nextConfig.generateEtags,\n                        poweredByHeader: nextConfig.poweredByHeader,\n                        result: RenderResult.fromStatic(matchedSegment, RSC_CONTENT_TYPE_HEADER),\n                        cacheControl: cacheEntry.cacheControl\n                    });\n                }\n                // Cache miss. Either a cache entry for this route has not been generated\n                // (which technically should not be possible when PPR is enabled, because\n                // at a minimum there should always be a fallback entry) or there's no\n                // match for the requested segment. Respond with a 204 No Content. We\n                // don't bother to respond with 404, because these requests are only\n                // issued as part of a prefetch.\n                res.statusCode = 204;\n                return sendRenderResult({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: RenderResult.EMPTY,\n                    cacheControl: cacheEntry.cacheControl\n                });\n            }\n            // If there's a callback for `onCacheEntry`, call it with the cache entry\n            // and the revalidate options. If we support RDC for Navigations, we\n            // prefer the `onCacheEntryV2` callback. Once RDC for Navigations is the\n            // default, we can remove the fallback to `onCacheEntry` as\n            // `onCacheEntryV2` is now fully supported.\n            const onCacheEntry = supportsRDCForNavigations ? getRequestMeta(req, 'onCacheEntryV2') ?? getRequestMeta(req, 'onCacheEntry') : getRequestMeta(req, 'onCacheEntry');\n            if (onCacheEntry) {\n                const finished = await onCacheEntry(cacheEntry, {\n                    url: getRequestMeta(req, 'initURL') ?? req.url\n                });\n                if (finished) return null;\n            }\n            if (cachedData.headers) {\n                const headers = {\n                    ...cachedData.headers\n                };\n                if (!isMinimalMode || !isSSG) {\n                    delete headers[NEXT_CACHE_TAGS_HEADER];\n                }\n                for (let [key, value] of Object.entries(headers)){\n                    if (typeof value === 'undefined') continue;\n                    if (Array.isArray(value)) {\n                        for (const v of value){\n                            res.appendHeader(key, v);\n                        }\n                    } else if (typeof value === 'number') {\n                        value = value.toString();\n                        res.appendHeader(key, value);\n                    } else {\n                        res.appendHeader(key, value);\n                    }\n                }\n            }\n            // Add the cache tags header to the response if it exists and we're in\n            // minimal mode while rendering a static page.\n            const tags = (_cachedData_headers = cachedData.headers) == null ? void 0 : _cachedData_headers[NEXT_CACHE_TAGS_HEADER];\n            if (isMinimalMode && isSSG && tags && typeof tags === 'string') {\n                res.setHeader(NEXT_CACHE_TAGS_HEADER, tags);\n            }\n            // If the request is a data request, then we shouldn't set the status code\n            // from the response because it should always be 200. This should be gated\n            // behind the experimental PPR flag.\n            if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n                res.statusCode = cachedData.status;\n            }\n            // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes\n            if (!isMinimalMode && cachedData.status && RedirectStatusCode[cachedData.status] && isRSCRequest) {\n                res.statusCode = 200;\n            }\n            // Mark that the request did postpone.\n            if (didPostpone && !isDynamicRSCRequest) {\n                res.setHeader(NEXT_DID_POSTPONE_HEADER, '1');\n            }\n            // we don't go through this block when preview mode is true\n            // as preview mode is a dynamic request (bypasses cache) and doesn't\n            // generate both HTML and payloads in the same request so continue to just\n            // return the generated payload\n            if (isRSCRequest && !isDraftMode) {\n                // If this is a dynamic RSC request, then stream the response.\n                if (typeof cachedData.rscData === 'undefined') {\n                    // If the response is not an RSC response, then we can't serve it.\n                    if (cachedData.html.contentType !== RSC_CONTENT_TYPE_HEADER) {\n                        if (nextConfig.cacheComponents) {\n                            res.statusCode = 404;\n                            return sendRenderResult({\n                                req,\n                                res,\n                                generateEtags: nextConfig.generateEtags,\n                                poweredByHeader: nextConfig.poweredByHeader,\n                                result: RenderResult.EMPTY,\n                                cacheControl: cacheEntry.cacheControl\n                            });\n                        } else {\n                            // Otherwise this case is not expected.\n                            throw Object.defineProperty(new InvariantError(`Expected RSC response, got ${cachedData.html.contentType}`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E789\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                    }\n                    return sendRenderResult({\n                        req,\n                        res,\n                        generateEtags: nextConfig.generateEtags,\n                        poweredByHeader: nextConfig.poweredByHeader,\n                        result: cachedData.html,\n                        cacheControl: cacheEntry.cacheControl\n                    });\n                }\n                // As this isn't a prefetch request, we should serve the static flight\n                // data.\n                return sendRenderResult({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: RenderResult.fromStatic(cachedData.rscData, RSC_CONTENT_TYPE_HEADER),\n                    cacheControl: cacheEntry.cacheControl\n                });\n            }\n            // This is a request for HTML data.\n            const body = cachedData.html;\n            // If there's no postponed state, we should just serve the HTML. This\n            // should also be the case for a resume request because it's completed\n            // as a server render (rather than a static render).\n            if (!didPostpone || isMinimalMode || isRSCRequest) {\n                // If we're in test mode, we should add a sentinel chunk to the response\n                // that's between the static and dynamic parts so we can compare the\n                // chunks and add assertions.\n                if (process.env.__NEXT_TEST_MODE && isMinimalMode && isRoutePPREnabled && body.contentType === HTML_CONTENT_TYPE_HEADER) {\n                    // As we're in minimal mode, the static part would have already been\n                    // streamed first. The only part that this streams is the dynamic part\n                    // so we should FIRST stream the sentinel and THEN the dynamic part.\n                    body.unshift(createPPRBoundarySentinel());\n                }\n                return sendRenderResult({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: body,\n                    cacheControl: cacheEntry.cacheControl\n                });\n            }\n            // If we're debugging the static shell or the dynamic API accesses, we\n            // should just serve the HTML without resuming the render. The returned\n            // HTML will be the static shell so all the Dynamic API's will be used\n            // during static generation.\n            if (isDebugStaticShell || isDebugDynamicAccesses) {\n                // Since we're not resuming the render, we need to at least add the\n                // closing body and html tags to create valid HTML.\n                body.push(new ReadableStream({\n                    start (controller) {\n                        controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML);\n                        controller.close();\n                    }\n                }));\n                return sendRenderResult({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: body,\n                    cacheControl: {\n                        revalidate: 0,\n                        expire: undefined\n                    }\n                });\n            }\n            // If we're in test mode, we should add a sentinel chunk to the response\n            // that's between the static and dynamic parts so we can compare the\n            // chunks and add assertions.\n            if (process.env.__NEXT_TEST_MODE) {\n                body.push(createPPRBoundarySentinel());\n            }\n            // This request has postponed, so let's create a new transformer that the\n            // dynamic data can pipe to that will attach the dynamic data to the end\n            // of the response.\n            const transformer = new TransformStream();\n            body.push(transformer.readable);\n            // Perform the render again, but this time, provide the postponed state.\n            // We don't await because we want the result to start streaming now, and\n            // we've already chained the transformer's readable to the render result.\n            doRender({\n                span,\n                postponed: cachedData.postponed,\n                // This is a resume render, not a fallback render, so we don't need to\n                // set this.\n                fallbackRouteParams: null,\n                forceStaticRender: false\n            }).then(async (result)=>{\n                var _result_value;\n                if (!result) {\n                    throw Object.defineProperty(new Error('Invariant: expected a result to be returned'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E463\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (((_result_value = result.value) == null ? void 0 : _result_value.kind) !== CachedRouteKind.APP_PAGE) {\n                    var _result_value1;\n                    throw Object.defineProperty(new Error(`Invariant: expected a page response, got ${(_result_value1 = result.value) == null ? void 0 : _result_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E305\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                // Pipe the resume result to the transformer.\n                await result.value.html.pipeTo(transformer.writable);\n            }).catch((err)=>{\n                // An error occurred during piping or preparing the render, abort\n                // the transformers writer so we can terminate the stream.\n                transformer.writable.abort(err).catch((e)=>{\n                    console.error(\"couldn't abort transformer\", e);\n                });\n            });\n            return sendRenderResult({\n                req,\n                res,\n                generateEtags: nextConfig.generateEtags,\n                poweredByHeader: nextConfig.poweredByHeader,\n                result: body,\n                // We don't want to cache the response if it has postponed data because\n                // the response being sent to the client it's dynamic parts are streamed\n                // to the client on the same request.\n                cacheControl: {\n                    revalidate: 0,\n                    expire: undefined\n                }\n            });\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            return await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'render',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration: isSSG,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        throw err;\n    }\n}\n// TODO: omit this from production builds, only test builds should include it\n/**\n * Creates a readable stream that emits a PPR boundary sentinel.\n *\n * @returns A readable stream that emits a PPR boundary sentinel.\n */ function createPPRBoundarySentinel() {\n    return new ReadableStream({\n        start (controller) {\n            controller.enqueue(new TextEncoder().encode('<!-- PPR_BOUNDARY_SENTINEL -->'));\n            controller.close();\n        }\n    });\n}\n\n//# sourceMappingURL=app-page.js.map\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}